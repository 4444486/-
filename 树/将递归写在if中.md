

|                             力扣                             | 难度 |
| :----------------------------------------------------------: | :--: |
| 965[单值树](https://leetcode.cn/problems/univalued-binary-tree/) |  🟢   |



## 将递归写在if条件判断中与for中

众所周知  递归函数在不断递出去后  仅仅只是在终点条件出return是不够的  它只能结束掉当前一个函数的形成  而之后的函数它会继续执行下面的代码 

目前碰到的递归代码写法有三种： 正常的函数嵌套 (例如二叉树的遍历)  它每一个函数的结束都是等函数执行完之后           写在for循环中的递归函数(例如有多分支的回溯代码)  它每当后面的递归函数返回后  之前的函数会继续执行for循环的下一轮  即走不同的决策 (因此写在for循环中的递归函数每一个状态的决策都会执行 )    然后递归函数才会终止        写在if条件判断作为判断条件的递归函数  一般都是对于一些特殊问题  即找到一个符合条件要求的决策即可  目的就是为了能够让下面的返回值直接影响上面的递归函数返回



例如965题的简单题求单值树：它只要找到一个不同的值 就需要终止掉所有的递归函数  然后返回false   因此可以将递归函数写在 if 条件判断中  ==>  如果下面递归出去的函数返回了一个false   就要将false一直向上传递  直到递归函数终止   所有就需要函数的提前终止

```c++
        if(!root) return true;  //这里当递归出去的节点不存在时应该返回true 因为如果返回false的话 那么上面所有的递归函数都会立即返回false

        if(root->left)				//将递归函数的返回值作为判断条件  只要下级返回了一个false那么上级就立刻返回false
            if(root->val != root->left->val || !isUnivalTree(root->left)) return false;
        if(root->right)
            if(root->val != root->right->val || !isUnivalTree(root->right)) return false;

        return true;
```

