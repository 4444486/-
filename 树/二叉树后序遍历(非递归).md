

## 对应力扣145题

二叉树后序遍历的其他几种写法都很简单 例如：使用递归  、 多创建一个数组或栈  按照中右左遍历   

上面这两种方法都跟前中序没有区别   而这里要总结的另外一种算法就是使用迭代并且不创建多余的数据或栈来完成 左右中的遍历



## 原理：要深刻理解递归(或者是自创栈) 让函数(或者是节点)入栈出栈的本质

不管是哪一种树的遍历方式  都需要先将左子树全部入栈  而前序和中序仅仅只是入栈的时机不同而已  但是后序则不一样了  **因为栈中每一个节点相对应的都是一棵树的根节点**  而将根节点出队要将它的左右子树全部遍历完了才能出队  所以**在取出栈中的元素的时候还要判断它的右子树有没有遍历**(左子树肯定是遍历过的  因为就是按照左子树的顺序放入栈中的)   

可以使用 pre 前驱节点来保存它遍历的前驱节点 （一开始为NULL）  它可以用来判断这个弹出栈的元素是刚遍历完左子树轮到它 还是刚遍历完右子树轮到它  如果是才遍历完左子树  那么就不能让它出栈 就去它的右子树继续遍历  如果pre指向它的右子树  说明是遍历完右子树(即将右子树的所有节点都从栈中弹出后)轮到它的那么就可以将该节点弹出栈！ 并且进行打印**(注意：整个过程只有这一个地方需要对节点进行处理  因为每一个节点相对应的都是树的根节点(既代表整颗树 又代表上层树的左右子节点)  因此只要对根节点进行处理即可) **



## 更新 pre 前驱指针的时机： 这个很重要  这个自我感觉是这一类方法的核心    首先要写出它的更新时机就要理解整个遍历过程节点的入栈和出栈时机   既然是在弹出节点的时候判断是否已经遍历完了左右子树的话  那么它的左右子树肯定会作为根节点被压入栈中  所以只需要在其他的节点在弹出栈的时候进行更新 pre 指针即可  这样在弹出一个节点需要进行判断的时候   pre 一定指向刚弹出的前一个结点  ==>  这个思想在大部分递归树中都有用到(例如树的线索化更新pre指针)！！！

```c++
vector<int> postorderTraversal(TreeNode* root) {
    vector<int> v;
    if(!root) return v;

    TreeNode *p = root;
    TreeNode *pp = NULL;
    stack<TreeNode *> s;

    while(s.empty() == false || p != NULL){
        while(p != NULL){
            s.push(p);
            p = p->left;
        }

        if(s.empty() == false){
            p = s.top();    
            //只需要在节点要出栈的时候进行更新pre指针即可  而出栈有两种情况都要考虑
            if(p->right == NULL || p->right == pp){
                s.pop();
                pp = p;
                v.push_back(p->val);
                p = NULL;  //这一点也很重要 就是在弹出该节点后 需要让p置空  否则又会将遍历过的左子树放入栈中
            }
            else{
                p = p->right;
            }
        }
    }
    return v;
}
```



## 先序或者后序遍历本质上跟DFS(深度优先搜索)一样 

深度优先搜索也是先遍历完与该节点相邻的所有其他节点后  才会遍历自身

例如：**遍历下标为0的节点 它指向了1节点   就会立刻将1节点作为链表的头节点进行遍历   等与1节点及其所有子节点都遍历完了之后 又会返回到0节点指向的下一个节点   对应于树中就是先遍历根节点 然后立即让它的子节点作为根节点进行遍历  等左子节点对应的那棵树遍历完了之后就返回到树的根节点  又让它的右子节点作为树的根节点进行遍历(这个过程对应于所有的节点都一样)**    而处理节点的时机就决定了是先序遍历还是后序遍历

