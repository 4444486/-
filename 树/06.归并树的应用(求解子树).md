

|                           LeetCode                           |                             åŠ›æ‰£                             | éš¾åº¦ |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :--: |
| [912. Sort an Array](https://leetcode.com/problems/sort-an-array/) | [912. æ’åºæ•°ç»„](https://leetcode.cn/problems/sort-an-array/) |  ğŸŸ    |
| [315. Count of Smaller Numbers After Self](https://leetcode.com/problems/count-of-smaller-numbers-after-self/) | [315. è®¡ç®—å³ä¾§å°äºå½“å‰å…ƒç´ çš„ä¸ªæ•°](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/) |  ğŸ”´   |
| [493. Reverse Pairs](https://leetcode.com/problems/reverse-pairs/) |  [493. ç¿»è½¬å¯¹](https://leetcode.cn/problems/reverse-pairs/)  |  ğŸ”´   |
| [327. Count of Range Sum](https://leetcode.com/problems/count-of-range-sum/) | [327. åŒºé—´å’Œçš„ä¸ªæ•°](https://leetcode.cn/problems/count-of-range-sum/) |  ğŸ”´   |



## å½’å¹¶æ’åº

é¦–å…ˆè¦äº†è§£å½’å¹¶æ ‘çš„åº”ç”¨   æœ€å…ˆè¦è§£å†³å½’å¹¶æ’åºçš„é—®é¢˜   å®ƒå®é™…ä¸Šæ˜¯ä¸€é¢—äºŒå‰æ ‘åˆ†æ²»é—®é¢˜   å°±æ˜¯**åˆ©ç”¨ååºéå†çš„ä»£ç æ¡†æ¶  é€’å½’è§£å†³å­é—®é¢˜**

![å¾®ä¿¡å›¾ç‰‡_20220529140732](C:\Users\14493\Desktop\img\å¾®ä¿¡å›¾ç‰‡_20220529140732.png) 

è¦ç‚¹ ï¼š åœ¨é€’å½’ä¹‹å‰æ‰¾åˆ°ä¸­é—´ç‚¹  ç„¶åå¼€å§‹é€’å½’   åœ¨é€’å½’åˆ°æœ€åå†å¼€å§‹é€ä¸€åˆå¹¶



**å½’å¹¶æ’åºå®ƒåªæ˜¯æ ‘è§£å†³åˆ†æ²»é—®é¢˜çš„ä¸€ç§æ’åºæ€æƒ³  è€Œè¿™ç§ç±»ä¼¼çš„æ€æƒ³èƒ½å¤Ÿè§£å†³è®¸å¤šå…¶ä»–æœ‰å…³å…ƒç´ é¡ºåºçš„é—®é¢˜**

## æ±‚æ•°ç»„çš„é€†åºå¯¹

æš´åŠ›è§£æ³•å°±æ˜¯ä¸¤å±‚forå¾ªç¯å³å¯æ±‚å‡º   ä½†è¿™é¢˜ç›®è¿˜å¯ä»¥ä½¿ç”¨åˆ†æ²»æ€æƒ³æ¥æ±‚è§£    **åœ¨ä¸€è¾¹è¿›è¡Œæ’åºæ—¶ ä¸€è¾¹è®¡ç®—è®©é€†åºå¯¹ä¸æ–­å¢åŠ    å› ä¸ºæ’å¥½åºä¹‹åå®ƒåœ¨è¿™ä¸ªåŒºé—´å°±ä¸ä¼šäº§ç”Ÿé€†åºå¯¹  å› æ­¤æ±‚é€†åºå¯¹æ˜¯ä¸æ–­å åŠ çš„è¿‡ç¨‹**    å¹¶ä¸”æ•°ç»„çš„æ€»é€†åºå¯¹å°±æ˜¯æ±‚å•ç‹¬æ±‚æ¯ä¸€ä¸ªå…ƒç´ çš„é€†åºå¯¹

![å¾®ä¿¡å›¾ç‰‡_20220529153751](C:\Users\14493\Desktop\img\å¾®ä¿¡å›¾ç‰‡_20220529153751.png) 

```c++
    int count = 0;
    vector<int> temp;
    int reversePairs(vector<int>& nums) {
        int size = nums.size();
        if(size == 0) return count;

        temp = vector<int>(size);
        sort(nums, 0, size-1);
        return count;
    }

    void sort (vector<int> &nums, int left, int right) {
        if (left == right) return;

        int mid = (right - left)/2 + left;
        sort(nums, left, mid);
        sort(nums, mid+1, right);
        merge(nums, left, mid, right);
    }
 
    void merge (vector<int> &nums, int left, int mid, int right) {
        for (int i = left; i <= right; ++i) temp[i] = nums[i];

        int low = left, high = mid+1;
        for (int i = left; i <= right; ++i) {
            if (low == mid+1) {
                nums[i] = temp[high++];
                count += mid-low+1;
            }
            else if (high == right+1) nums[i] = temp[low++];
            else if (temp[low] <= temp[high]) nums[i] = temp[low++];
            else {
                nums[i] = temp[high++];
                count += mid-low+1;
            }
        }
    }
```



æ±‚é€†åºå¯¹è¿˜å¯ä»¥å€ŸåŠ©å¦å¤–ä¸€ç§æ•°æ®ç»“æ„ ==>  æ ‘çŠ¶æ•°ç»„

```c++
class bitTree {
public:
    int n;
    vector<int> tree;

    bitTree(int n){
        this->n = n;
        tree.resize(n+1);
    }

    int lowbit(int i) {
        return i & -i;
    }
    
	//æŸ¥è¯¢æ¯”valueå°çš„å…ƒç´ å…±æœ‰å¤šå°‘ä¸ª
    int query (int value) {
        int sum = 0;
        for(; value > 0; value -= lowbit(value)) sum += tree[value];
        return sum;
    }
	//å•ç‚¹æ›´æ–° ä¼ å…¥ä¸€ä¸ªå…ƒç´  ç„¶åè¿›è¡Œæ›´æ–° æ›´æ–°çš„å€¼ä¸º1
    void update (int value) {
        for(; value <= n; value += lowbit(value)) ++tree[value];
    }
};

class Solution {
public:
    int reversePairs(vector<int>& nums) {
        int res = 0;
        if(nums.size() == 0) return res;

        vector<int> temp = nums;
        //ç¦»æ•£åŒ–çš„å‰æå¿…é¡»æ˜¯æœ‰åºçš„æ•°ç»„ è¿™æ ·æ‰èƒ½å¾—çŸ¥è¯¥å…ƒç´ æ’åç¬¬å‡ 
        sort(temp.begin(), temp.end());
        for(auto &item : nums) {
            //binary_searchä½œç”¨æ˜¯è¿”å›å¤§äºç­‰äºè¯¥å…ƒç´ çš„ä¸‹æ ‡(å¦‚æœç­‰äºå°±è¿”å›æœ€å·¦è¾¹çš„é‚£ä¸ª)
            item = binary_search(temp, item) + 1;
        }

        int n = nums.size();
        bitTree tree(n);
        //å› ä¸ºæ˜¯æ±‚é€†åºå¯¹  æ‰€ä»¥è¦è¿›è¡ŒåŠ¨æ€çš„æ•°ç»„æ›´æ–°
        //å¹¶ä¸”å¿…é¡»ä»åå¾€å‰è¿›è¡Œéå†  ==>  å› ä¸ºæ ‘çŠ¶æ•°ç»„åªèƒ½æ±‚å¾—æ¯”è¯¥å…ƒç´ å°çš„å…ƒç´ å…±æœ‰å¤šå°‘ä¸ª æ‰€ä»¥ä»åå¾€å‰ è¿™æ ·è¶Šå°çš„å…ƒç´ æ’åœ¨è¶Šå  å®ƒä¼šè¢«å…ˆè¿›è¡Œæ•°ç»„çš„æ›´æ–°  è¿™æ ·åœ¨éå†åˆ°å‰é¢è¾ƒå¤§çš„å…ƒç´ æ—¶  å°±çŸ¥é“æœ‰å¤šå°‘ä¸ªæ¯”å®ƒå°çš„å…ƒç´ æ’åœ¨å®ƒçš„åé¢(å³é€†åºå¯¹)
        for(int i = n-1; i >= 0; --i){
            //æŸ¥è¯¢æ¯”è¯¥å…ƒç´ å°çš„å°±è¦-1  ä¸èƒ½åŒ…æ‹¬è‡ªèº«
            res += tree.query(nums[i] - 1);
            tree.update(nums[i]);
        }

        return res;
    }

    int binary_search (vector<int> &nums, int value) {

        int left = 0, right = nums.size();
        while (left < right) {
            int mid = (right - left)/2 + left;
            if(nums[mid] >= value) right = mid;
            else left = mid + 1;
        }

        return right;
    }
};
```



## æ±‚æ¯ä¸€ä¸ªå…ƒç´ åé¢æ¯”å®ƒå¤§çš„ä¸ªæ•°

ä¸ä¸Šé¢ç±»ä¼¼  ä¸è¿‡è¿™ä¸€æ¬¡è¦æ±‚å¾—å…·ä½“æ˜¯å“ªä¸€ä¸ªå…ƒç´    å°±æ˜¯åœ¨åˆå¹¶çš„æ—¶å€™è®¡ç®—countè¦åˆ†å¼€è®¡ç®—ç»Ÿè®¡   å¹¶ä¸”è¦çŸ¥é“å…·ä½“æ˜¯å“ªä¸€ä¸ªå…ƒç´    æ‰€ä»¥è¦äº‹å…ˆç»Ÿè®¡  

**å› æ­¤è¦ä½¿ç”¨ä¸€ç§æ•°æ®ç»“æ„æ¥ä¿å­˜æ¯ä¸€ä¸ªå…ƒç´ å¯¹åº”çš„ä¸‹æ ‡ï¼š  ç¬¬ä¸€æ—¶é—´å¯ä»¥æƒ³åˆ°ä½¿ç”¨å“ˆå¸Œè¡¨æ¥å­˜å‚¨   ä½†æ˜¯å“ˆå¸Œè¡¨å¹¶ä¸èƒ½å­˜å‚¨ç›¸åŒçš„key   æ‰€ä»¥å¯ä»¥ä½¿ç”¨ä¸€ä¸ªæ•°ç»„æ¥å­˜æ”¾pairå¯¹ç»„æ¥å®ç°**     

ä½†æ˜¯è¿™æ—¶å€™åˆæœ‰ä¸€ä¸ªé—®é¢˜ï¼šå¦‚æœä½¿ç”¨åŸæ•°ç»„æ¥è¿›è¡Œå½’å¹¶çš„è¯  å®ƒéœ€è¦æ ¹æ®valueå€¼æ¥æŸ¥è¯¢å®ƒçš„ä¸‹æ ‡   ä½†æ˜¯å­˜æ”¾pairå¯¹ç»„çš„æ•°ç»„å¹¶ä¸æ”¯æŒå¿«é€Ÿçš„æŸ¥æ‰¾æŸä¸ªå…ƒç´ çš„ä¸‹æ ‡  å®ƒä¹Ÿæ˜¯æŒ‰ç…§ä¸‹æ ‡ä»å°åˆ°å¤§å­˜å‚¨å¯¹ç»„çš„    å› æ­¤å½’å¹¶æ’åºä¸èƒ½å¯¹åŸæ•°ç»„è¿›è¡Œæ’åº   è¦å¯¹pairæ•°ç»„è¿›è¡Œæ’åº

```c++
    vector<int> count;
    vector<pair<int, int>> pairArr;
    vector<pair<int, int>> temp;

    vector<int> countSmaller(vector<int>& nums) {
        int n = nums.size();
        count.resize(n);
        pairArr.resize(n);
        temp.resize(n);
        for(int i = 0; i < n; ++i) pairArr[i] = pair<int, int>(nums[i], i);

        sort(pairArr, 0, n-1);
        return count;
    }
    void sort (vector<pair<int, int>>& pairArr, int left, int right) {
        if(left == right) return;

        int mid = (right - left)/2 + left;
        sort(pairArr, left, mid);
        sort(pairArr, mid+1, right);
        merge(pairArr, left, mid, right);
    }
    void merge (vector<pair<int, int>>& arr, int left, int mid, int right) {
        for (int i = left; i <= right; ++i) {
            temp[i] = arr[i];
        }

        int low = left, high = mid+1;
        for (int i = left; i <= right; ++i) {
            if (low == mid+1) arr[i] = temp[high++];
            else if (high == right+1) {
                arr[i] = temp[low++];
                count[arr[i].second] += high-mid-1;
            }
            else if (temp[low].first > temp[high].first) arr[i] = temp[high++];
            else {
                arr[i] = temp[low++];
                count[arr[i].second] += high-mid-1;
            }
        }
    }
```



## ç¿»è½¬å¯¹

æ¯æ¬¡åˆå¹¶ä¹‹å‰éƒ½éœ€è¦å»æŸ¥æ‰¾ä¸€è¾¹åé¢ä¸€åŠçš„æ•°ç»„ç¬¦åˆè¦æ±‚çš„å…ƒç´ ä¸ªæ•°     ä½†æ˜¯å¦‚æœç›´æ¥ä½¿ç”¨foråµŒå¥—ä¼šè¶…æ—¶ è·Ÿæš´åŠ›è§£æ³•æ²¡åŒºåˆ«    å› ä¸ºæ˜¯åœ¨å½’å¹¶ä¸­è¿›è¡Œçš„  æ‰€ä»¥å¯ä»¥å……åˆ†åˆ©ç”¨å·²ç»æ’å¥½åºçš„ç‰¹ç‚¹æ¥è®¡ç®—ä¸ªæ•°

```c++
    int count = 0;
    vector<int> temp;

    int reversePairs(vector<int>& nums) {
        temp.resize(nums.size());
        sort(nums, 0, nums.size()-1);
        return count;
    }

    void sort (vector<int> &nums, int left, int right) {
        if (left == right) return;

        int mid = (right - left)/2 + left;
        sort(nums, left, mid);
        sort(nums, mid+1, right);
        merge(nums, left, mid, right);
    }

    void merge (vector<int> &nums, int left, int mid, int right) {
        for(int i = left; i <= right; ++i) temp[i] = nums[i];

        int end = mid+1;
        for(int i = left; i <= mid; ++i){
            while(end <= right && (long)temp[i] > (long)2*temp[end]) ++end;

            count += end - (mid + 1);
        }

        int low = left, high = mid+1;
        for (int i = left; i <= right; ++i) {
            if(low == mid+1) nums[i] = temp[high++];
            else if(high == right+1) nums[i] = temp[low++];
            else if(temp[low] <= temp[high]) nums[i] = temp[low++];
            else nums[i] = temp[high++];
        }
    }
```



