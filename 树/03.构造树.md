|                           LeetCode                           |                             åŠ›æ‰£                             | éš¾åº¦ |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :--: |
| [654. Maximum Binary Tree](https://leetcode.com/problems/maximum-binary-tree/) | [654. æœ€å¤§äºŒå‰æ ‘](https://leetcode.cn/problems/maximum-binary-tree/) |  ğŸŸ    |
| [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) | [105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) |  ğŸŸ    |
| [106. Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) | [106. ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) |  ğŸŸ    |
| [889. Construct Binary Tree from Preorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/) | [889. æ ¹æ®å‰åºå’Œååºéå†æ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/) |  ğŸŸ    |



## æœ€å¤§äºŒå‰æ ‘

æ¯æ¬¡éƒ½æ˜¯åœ¨ä¸€ä¸ªåŒºé—´ä¸­å…ˆæ‰¾ä¸€ä¸ªæœ€å¤§å€¼ç„¶åæ„é€ è¯¥èŠ‚ç‚¹    å°†å®ƒä½œä¸ºæ ¹èŠ‚ç‚¹å†å»æ„é€ å·¦å³å­æ ‘  ä¼šå‘ç°æ¯ä¸€æ­¥éƒ½æ˜¯ç›¸åŒçš„æ­¥éª¤  æ‰€ä»¥ä½¿ç”¨å‰åºé€’å½’çš„å¥—è·¯æ¥å®ç°

```c++
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return build(nums, 0, nums.size());
    }

    TreeNode *build (vector<int>& nums, int left, int right) {
        if(left >= right) return nullptr;
		
        //æ¯ä¸€æ¬¡æ‰¾åˆ°åŒºé—´ä¸­çš„æœ€å¤§å€¼
        int maxPos = left;
        for (int i = left+1; i < right; ++i) {
            if (nums[i] > nums[maxPos]) maxPos = i;
        }
	
        TreeNode *root = new TreeNode(nums[maxPos]);
        //å…ˆé€’å½’æ„é€ å·¦å­æ ‘  ç„¶åå†è‡ªåº•å‘ä¸Šæ„é€ å³å­æ ‘ï¼ï¼ï¼ ç†è§£è¿™ä¸€ç‚¹å¾ˆé‡è¦
        root->left = build(nums, left, maxPos);
        root->right = build(nums, maxPos+1, right);
        return root;
    }
```

<img src="C:\Users\14493\Desktop\img\QQå›¾ç‰‡20220528195019.png" alt="QQå›¾ç‰‡20220528195019" style="zoom: 25%;" /> å¦‚å›¾  å› ä¸ºæ˜¯DFSæ·±åº¦é€’å½’  æ‰€ä»¥ä¸€å®šæ˜¯å…ˆæ„é€ å®Œä¸€æ•´æ¡é“¾è¡¨åå†è¿”å›æ„é€ å…¶å¦ä¸€åŠ



## ä»å‰åºå’Œä¸­åºæ„é€ æ ‘

åˆ©ç”¨å‰åºéå†çš„é¡ºåºæ¥å…ˆæ„é€ å·¦è¾¹çš„ä¸€æ¡é“¾è¡¨  ç„¶åå†ä»ä¸‹å¾€ä¸Šä¾æ¬¡æ„é€ å³å­æ ‘   æ‰€ä»¥å¯ä»¥ä½¿ç”¨ä¸€ä¸ªorderæ¥æŒ‡å‘å‰åºæ•°ç»„çš„å…ƒç´   åˆ›å»ºä¸€ä¸ªèŠ‚ç‚¹å°±åŠ 1

```c++
    int order = 0;

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(preorder.size() == 1) return new TreeNode(preorder[0]);

        unordered_map<int, int> mp;
        for (int i = 0; i < inorder.size(); ++i) mp[inorder[i]] = i;

        return build(preorder, inorder, 0, preorder.size()-1, mp);
    }

    TreeNode *build (vector<int>& preorder, vector<int>& inorder, int left, int right, unordered_map<int, int>&mp) {
        if (left > right) return nullptr;

        int value = preorder[order++];
        int pos = mp[value];

        TreeNode *root = new TreeNode(value);
        root->left = build(preorder, inorder, left, pos-1, mp);
        root->right = build(preorder, inorder, pos+1, right, mp);
        return root;
    }
```



è¿™ä¸€ç§æ–¹æ³•æ˜¯åˆ†åˆ«ä¼ å…¥ä¸¤ä¸ªæ•°ç»„çš„å·¦å³è¾¹ç•Œ   è¿™æ ·ä¸éœ€è¦ä½¿ç”¨orderæ¥è®¡ç®—å‰åºçš„å…ƒç´    **åŒæ—¶è¿™ç§æ–¹æ³•æ›´æ™®éé€‚ç”¨ ä¸Šé¢ä¸€ç§ä¸æ–­åŠ 1åªé€‚ç”¨äºå‰åºæˆ–è€…ååºè¿™ä¸¤ç§å…ƒç´ æ’åˆ—æœ‰åºçš„æ•°ç»„ä¸­     è€Œè¿™ç§æ¯æ¬¡éƒ½é‡æ–°è®¡ç®—æ•°ç»„è¾¹ç•Œçš„  å¯ä»¥åº”å¯¹å…ƒç´ è·³ç€æ’åˆ—çš„æ•°ç»„**

```c++
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(preorder.size() == 1) return new TreeNode(preorder[0]);

        unordered_map<int, int> mp;
        for(int i = 0; i < inorder.size(); ++i) mp[inorder[i]] = i;
        return build(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1, mp);
    }

    TreeNode *build (vector<int>& preorder, int preLeft, int preRight, vector<int>& inorder, int inLeft, int inRight, unordered_map<int, int>& mp) {

        if(preLeft > preRight) return nullptr;

        int value = preorder[preLeft];
        int index = mp[value];
        TreeNode *root = new TreeNode(value);

        int leftSize = index - inLeft;
        root->left = build(preorder, preLeft+1, preLeft+leftSize, inorder, inLeft, index-1, mp);
        root->right = build(preorder, preLeft+leftSize+1, preRight, inorder, index+1, inRight, mp);
        return root;
    }
```



## ä¸­åºå’Œååºæ„é€ æ ‘

æ³¨æ„ï¼šå¦‚æœä½¿ç”¨ä¸€ä¸ªå˜é‡æ¥ååºæ•°ç»„çš„è¯   å®ƒéœ€è¦ä»åå¾€å‰   å› ä¸ºååºæ•°ç»„çš„æ ¹èŠ‚ç‚¹åœ¨æ•°ç»„çš„æœ€å   **å¹¶ä¸”é€’å½’çš„æ—¶å€™è¦å…ˆæ„é€ å³å­æ ‘å†æ„é€ å·¦å­æ ‘ï¼ï¼ï¼**

```c++
    TreeNode *build (vector<int>& inorder, vector<int>& postorder, int left, int right) {
        if(left > right) return nullptr;

        int value = postorder[order--];
        int index = mp[value];
        TreeNode *root = new TreeNode(value);
        //å¿…é¡»å…ˆæ„é€ å³å­æ ‘å†æ„é€ å·¦å­æ ‘
        root->right = build(inorder, postorder, index+1, right);
        root->left = build(inorder, postorder, left, index-1);
        return root;
    }
```



## å…ˆåºå’Œååºæ„é€ æ ‘

**å…ˆåºå’Œååºæ¯”è¾ƒç‰¹æ®Š  æä¾›å®ƒä»¬ä¸¤ä¸ªæ•°ç»„æ„é€ å‡ºæ¥çš„æ ‘å¹¶ä¸æ˜¯å”¯ä¸€çš„    å¹¶ä¸”å‰åºçš„æ ¹èŠ‚ç‚¹å¯¹åº”åˆ°ååºå¹¶ä¸æ˜¯å·¦è¾¹éƒ½æ˜¯å·¦å­æ ‘çš„èŠ‚ç‚¹ å³è¾¹éƒ½æ˜¯å³å­æ ‘çš„èŠ‚ç‚¹   ä¸å…¶è¯´æ˜¯å®ƒä»¬ä¸¤ä¸ªæ•°ç»„ç‰¹æ®Š  å€’ä¸å¦‚è¯´æ˜¯ä¸­åºçš„æ•°ç»„ç‰¹æ®Š(æ‰¾åˆ°äº†æ ¹èŠ‚ç‚¹  å·¦è¾¹çš„å°±å…¨éƒ¨æ˜¯å·¦å­æ ‘  å³è¾¹å°±æ˜¯å³å­æ ‘)**

```c++
    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {

        unordered_map<int, int> mp;
        for(int i = 0; i < postorder.size(); ++i) mp[postorder[i]] = i;

        return build(preorder, 0, preorder.size()-1, postorder, 0, postorder.size()-1, mp);
    }   

    TreeNode *build (vector<int>& preorder, int preLeft, int preRight, vector<int>& postorder, int postLeft, int postRight, unordered_map<int, int>& mp) {
        if(preLeft > preRight) return nullptr;
        //è¿™é‡Œéœ€è¦æ³¨æ„ å¤šæ·»åŠ ä¸€ä¸ªé€€å‡ºå‡½æ•°çš„æ¡ä»¶ å› ä¸ºä¸‹é¢è¦æœ‰å–preLeft+1çš„æ“ä½œ å¦‚æœä¸é€€å‡ºä¼šå‡ºç°æ•°ç»„è¶Šç•Œ
        if(preLeft == preRight) return new TreeNode(preorder[preLeft]);

        //è¿™æ˜¯å½“å‰æ ¹èŠ‚ç‚¹çš„å€¼
        int rootvalue = preorder[preLeft];
        //è¿™æ˜¯å·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹çš„å€¼  åœ¨æ ¹èŠ‚ç‚¹çš„åé¢ä¸€ä¸ªä½ç½®
        int leftRootValue = preorder[preLeft+1];
        //ç„¶åå–å·¦å­æ ‘æ ¹èŠ‚ç‚¹çš„ç´¢å¼•
        int index = mp[leftRootValue];
        //è¿™æ˜¯å–å·¦å­æ ‘ä¸­å…ƒç´ çš„ä¸ªæ•°(è¦åŠ ä¸Šæ ¹èŠ‚ç‚¹è‡ªèº«)
        int leftsize = index - postLeft + 1;

        TreeNode *root = new TreeNode(value);
        root->left = build(preorder, preLeft+1, preLeft+leftsize, postorder, postLeft, index, mp);
        root->right = build(preorder, preLeft+leftsize+1, preRight, postorder, index+1, postRight-1, mp);

        return root;
    }
```



åŒæ ·ä½¿ç”¨orderæ¥è®°å½•å‰åºæ•°ç»„   ä¹Ÿå¯ä»¥å°†ååºæ•°ç»„ä½œä¸ºæ ¹èŠ‚ç‚¹æ•°ç»„æ¥æ„é€   éƒ½ä¸€æ ·

```c++
    unordered_map<int, int> mp;
    int order = 0;

    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {

        for(int i = 0; i < postorder.size(); ++i) mp[postorder[i]] = i;

        return build(preorder, postorder, 0, postorder.size()-1);
    }   
    TreeNode *build (vector<int>& preorder, vector<int>& postorder, int left, int right) {
        if(left > right) return nullptr;
        if(left == right) return new TreeNode(preorder[order++]);

        int rootValue = preorder[order++];
        int leftRootValue = preorder[order];
        int index = mp[leftRootValue];
        TreeNode *root = new TreeNode(rootValue);
        root->left = build(preorder, postorder, left, index);
        root->right = build(preorder, postorder, index+1, right-1);
        return root;
    }
```

