

## 对应力扣144、145题

## (动态线索化)morris充分利用叶子节点的空结点特性  先让它们指向后驱结点  然后再一个个遍历

首先贴出morris遍历的几个步骤：先序：

1. 让curr指向开始的结点  然后检查它是否有左子树

2. 如果没有左子树的话就打印curr指向的这个节点  然后让curr向右移动一步  继续从第一步开始

3. 如果有左子树的话：

   1. 就找到curr的前驱节点 即找到curr左子树中的最右边一个节点  再判断它的右指针是否为空  如果为空(说明curr就是左子树的根节点  并且还未进行遍历)就指向curr所在的节点   并且curr向左移动一步  继续开始第一步循环(再判断有无左子树)
   2. 如果不为空就让 它置空(恢复树原来的形状)   并且curr向右移动一步(说明这个根节点的左子树已经遍历完毕了)

   



1. 这上面的第一步判断是否有左子树的作用不仅仅是为了去遍历左子树或者右子树  还有另外一个作用就是当curr已经遍历到叶节点后判断左子树为空 然后向右走一步  就可以回到原来的根节点位置     然后回到原来的位置之后 判断左子树的最右节点的右指针不为空 说明curr已经遍历完成回来了 然后让它置空即可

   

2. 这里面去查找左子树的最右节点就是创建了一个"探路指针"    先说一下当右指针为空的情况：如果为空  说明curr这个根节点还未开始遍历左子树  只是放了一个探路指针去找节点   所以如果是前序遍历的话就应该在这时候打印根节点     当探路指针将它的右指针指向了curr 就完成了返回路径的修建  然后curr这个指针就可以安心的前往左子树一个一个地进行遍历 (因为有可以回家的路)  为什么要回到根节点呢？ 因为它的右子树还没遍历 

   然后如果右指针不为空的话  就让它置空(说明这个左子树已经遍历完毕了)  然后curr向右移动一步再去循环遍历右子树

   

3. 而该循环的终止条件就是curr为空时 因为只有遍历到右子树的最右边一个节点才算是遍历完了一棵树  **而它相对于其他的节点不可能成为左子树的一员**  上面的操作都是去左子树找最右节点   所以这个终点节点不可能会被探路指针找到

![image-20220521210706892](C:\Users\14493\AppData\Roaming\Typora\typora-user-images\image-20220521210706892.png) 



总结：  

遍历的步骤一共可以分为两步：1.让探路指针去修建能够回到根节点的路  然后curr开始遍历左子树   2.一直遍历完左子树后返回的时候借助之前修好的路让curr向右移动一步即可

## 因为树都是相对的  即使只有一个节点也可以称作为树  所以只要当curr向左或向右移动了一步  就说明要去遍历相对应的左子树或者右子树了  就要立即开始下一次循环 不能有多余的操作    这跟递归很像  只要向下开始遍历 都会把下面的节点也当作一颗完全一样的树  而写在递归代码下面的操作实际是返回时的操作(因此不管是递出去的代码还是归回来的代码 它们都要能解决三种树：1.无左右子节点的树  2.只有单边的树  3.两边都有子节点的树)    



```c++
vector<int> preorderTraversal(TreeNode* root) {
    vector<int> v;
    if(!root) return v;

    TreeNode *curr = root;
    TreeNode *mostR = NULL;
    while(curr != NULL){
        if(curr->left != NULL){
            TreeNode *mostR = curr->left;
            while(mostR->right != NULL && mostR->right != curr){
                mostR = mostR->right;
            }
            if(mostR->right == NULL){
                mostR->right = curr;
                v.push_back(curr->val);
                curr = curr->left;
                continue;
            }
            else{
                mostR->right = NULL;
            }
        }
        else{
            v.push_back(curr->val);
        }
        curr = curr->right;
    } 
    return v;
}
```

