

## 引用接收常量报错

```c++
void test (int &a) {  //报错 不能使用引用来接收
	cout << a << endl;
}

test(5); 
//因为传进去的是一个常量 而这个常量在传入后就已经被销毁了 所以不能使用引用来接收 否则会指向一个非法地址

//可以在前面加上const来限制它不能进行修改 这样编译器就能通过(貌似是优化)
void test (const int &a) { //正确
	cout << a << endl;
}

const int a = 5;
test(a);  //这样子传入一个a  虽然传入后这个常量不会被销毁 但它是不可修改的 所以在函数接收的时候也不能仅仅使用引用 需要在前面加上const
```



## const和引用不能同时使用的情况(仅仅只有指针会出现这种情况)

在接收一个指针时 如果实参的指针是非const类型 那么函数接收就不能const & 一起使用

```c++
void test2 (const int *&a) {  //报错
	cout << *a << endl;
}

int b = 10;
int *p = &b;
test2(p);

//如果单独使用const 或者 & 就不会报错
void test2 (const int *a) {  //正确
	cout << *a << endl;
}

void test2 (int *&a) {  //正确
	cout << *a << endl;
}

//这是因为使用引用&来接收实参说明并不会在函数中创建一个新的变量 而是创建一个指针指向那个实参
//在上面如果使用 int *&a 来接收 那么这个a变量就指向了外部传进来的 p 指针   那么单独使用引用是合法的 将a当作p来使用即可

//但是如果在前面加上const就说明限制这个形参里面的值不能修改 而这个形参是外部实参的引用  但外部实参是一个可修改的指针
//这样从一个函数内部对外部的变量进行限制   C++默认是不允许的
```



## 函数的可变形参不能作为局部变量数组的长度

```c++
void test (int n) {
	int arr[n];  //行为形参是可变的 所以会报错 variable-sized object may not be initialized (可变的size不能用于初始化)
    
    //因此要用n作为数组长度的话 只能开辟堆内存 或者使用 vector
}
```

