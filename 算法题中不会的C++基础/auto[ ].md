

## auto [ ]  能够自动类型推导 并接收右值中的每一个元素

首先需要明确的是：只要是从数组中或者队列或者map中取出来的元素 都属于右值  因此可以使用左值引用或者右值引用

```c++
pair<int, int> p1(5, 3);
vector<pair<int, int>> arr;
arr.emplace_back(p1);

auto[a1, a2] = arr[0];  //auto[a1, a2] 接收了arr[0]的元素 因为没有使用引用 因此执行了拷贝构造
auto &[a1, a2] = arr[0];  //左值引用  没有执行拷贝构造 因此可以修改arr[0]中的值(这里为什么左值引用能修改常量的值呢？ -->  因为这是pair对组 只要不修改这个容器即可  里面的元素是可以修改的  就类似于const数组一样  只要不修改指针的指向即可)
auto &&[a1, a2] = arr[0];  //右值引用 
```

 

## 使用()初始化 和{}初始化的区别

使用 () 传递参数实际上是调用了内部的构造函数    

```c++
    AStar (int a): a(a) {  //例如类的构造函数 可以使用int的默认构造函数来初始化成员属性a
    }

	//也可以使用 {} 来初始化a
	AStar (int a): a{a} {}  //这是使用了初始化列表来创建成员属性a
```



emplace 和 push 的区别

```c++
arr.emplace_back(5);  //可以传入一个常量 emplace它会直接使用右值引用！！  
arr.push_back(5);  //push并不会使用右值引用  而是会在数组的尾部创建一个5  然后抛弃原来传递进来的5

//因此 如果要快捷创建类似pair对组的话 emplace可以直接传递pair的两个参数
arr.emplace_back(4, 3);
//但是push就必须使用初始化列表
arr.push_back({4, 3});   //它意味着必须传递进来一个pair  然后在尾部创建一个相同的pair  再抛弃之前传递进来的pair
```

