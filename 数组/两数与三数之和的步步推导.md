

## 使用双指针求和的本质

摘抄一段力扣：

**这个方法就是我们常说的「双指针」，当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 O(N^2)减少至 O(N)。为什么是 O(N) 呢？这是因为在枚举的过程每一步中，「左指针」会向右移动一个位置（也就是题目中的 b），而「右指针」会向左移动若干个位置，这个与数组的元素有关，但我们知道它一共会移动的位置数为 O(N)，均摊下来，每次也向左移动一个位置，因此时间复杂度为 O(N)。**



## 通过数组双指针求三个数之和来逐步探究其本质(返回数的下标)

首先 我们先解决一个最简单的问题 即求两数之和(并返回两个数的下标)  ：可以使用暴力的解法直接双重 for 循环

但是如果要求返回的两个数不能重复的话  应该怎么解决？  ==>  这时候就必须先给数组排序了   如果不给数组排序的话  那么就要每次添加一对新数的时候都需要遍历一遍存放所有对数的vector 极其浪费时间     所以就必须先给数组排序

那排好序后如何确保后面添加的对数不会与之前的重复呢？  **可以让指针在一个元素成功添加进数组中后  就直接移动指针 直到指向的元素不等于该元素即可(因为数组是有序的  所以之后的元素一定不会出现之前出现过的元素  只需要跳过重复的即可)**   

但是：上述操作的时间复杂度还是 O(n^2)    ==>   由于数组是有序的  而且需要寻找的目标值不会变   那么如果在下标为 i = 2,  j = 8 的地方成功找到这一对符合条件的元素 然后添加进vector中   接下来 i 指针会向右移动   **仔细观察一下可以发现  只要 i 向右移动了  那么下一次要找的元素 j 指针的下标一定是小于 8 的  这样才有可能找到下一对和为target的元素**   

由上就能够得到一种新的数组遍历方法：**双指针**  即一个指针从头开始向尾移动  另一个指针从尾开始向头移动    不断缩小目标区间  只要找到了一对 那么下一对元素出现的位置一定是在区间更小的范围内    因为可以继续移动指针直到两个指针相遇为止

## 当然了  如果题目要求返回无序数组元素的下标的话  那么就不能手动进行排序 了   如果能在无序的情况下使用双指针最好  不能的话只能使用暴力或者哈希表(例如力扣的第一题)     还有需要特别重视的一点就是在while循环中该移动left还是移动right 这一点很关键



**上述将两个指针不断向中间缩小区间在二维坐标中体现：**

不断缩减区间的本质：[https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/solution/yi-zhang-tu-gao-su-ni-on-de-shuang-zhi-zhen-jie-fa/

**所以即使是一维的数组也可以看作是二维的决策状态图  只不过每次缩减区间的范围变大了   而类似于棋盘等问题  每次就仅仅只是缩减一个格子的区间  因此那些题目的暴力枚举复杂度就高**



解决了双指针搜索有序的两数之和和无序的两数之和后  可以将它推广到双指针搜索三数之和：

题目要求：返回三个之和等于 target 的数  并且不能有重复的(三个元素的下标各不相同  同时每一个三元组不能相同)

首先第一点数组必须有序的    既然能够通过双指针一个从头开始 一个从尾开始  来寻找到两数之和   那么可以在外面再嵌套一层 for 循环从 i = 0 开始   然后里面的第二层循环从 i + 1 开始   第三层循环的指针每一次都从尾部开始    还需要进行一些剪枝操作   当第二层循环的指针与第三层相等的话   就可以停止这个循环    还有第一层的 for 循环指针要建立在与上一个元素不同的情况下才能开始循环  例如：**第一次 for 循环指向的元素为 1  下一次循环就必须要跳过所有元素 1**               **三数之和中需要注意的一点是第二层for循环和第三层for循环每一次在第一层for循环重新开始后  指针都会重置  一个指向 i + 1 一个指向尾部**

```c++
	for(int i = 0; i < nums.size(); ++i){
            //第三层for循环的指针
            int third = nums.size() - 1;
            int target = -nums[i];
        	//不能与上一次循环的元素相同 需要跳过
            if(i == 0 || nums[i] != nums[i-1]){
                for(int j = i + 1; j < nums.size(); ++j){
                    //在第一层循环的基础上  第二层的元素不能与上一次相同
                    if(j == i + 1 || nums[j] != nums[j-1]){
                        //当和大于target就需要将尾部指向q
                        while(j < third && nums[j] + nums[third] > target) --third;
                        //当第二层指针与第三层相遇时就停止第二层循环内部的循环
                        if(third == j) break;

                        if(nums[j] + nums[third] == target){
                            v.push_back({nums[i], nums[j], nums[third]});
                        }
                    }
                }
            }
        }
```



## 最后来说一说为什么通过双指针就能将O(n^2) 变成O(n)  以及什么情况能使用双指针

1. 从O(n^2) 变成 O(n) ：上面的一个超链接解释了两个指针的二维坐标画法  O(n^2) 就是不断遍历一个一个的格子  然后遍历一个舍弃一个  直到全部遍历结束  n*n大小的二维坐标图   时间复杂度自然是O(n^2)    而利用双指针它遍历到一个元素后  只要指针移过了它  它就不可能再次作为区间数组的元素   这体现到二维坐标图中就是一次排除一行的元素格子   自然复杂度就为 n   ==>  **暴力的双重for循环有点类似于递归  派一个指针遍历一遍之后 有递归回到之前位置的下一个坐标**
2. 什么情况使用双指针： 就是观察是否一个数组元素只需要考察一遍   只要考察过一遍之后  它就不可能与其他元素再构成目标值   指针就不会回头  ==>  这种双指针遍历的优化   类似于给暴力回溯添加备忘录或者是动态规划   就是计算过一遍的状态就不会再回头计算第二遍



## 找到一道类似于上面一行或一列缩小区间的题目(Z型搜索)

[在矩阵中找到目标元素](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

