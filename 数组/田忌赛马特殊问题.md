

## 特殊的田忌赛马题

当点数与对方相同时  就算输  只有大于才算赢   **给定两个等长的数组(不是有序的)**  重新组成一个赢面最大的数组返回

这里面有贪心的思想：每次都出自己点数刚好大于对方的牌   如果没有大于它的牌  就出最小的一张牌来止损

**但是这样做题的话会有一个问题**：数组不是有序的   每次碰到对面的牌  都需要在自己的牌堆中进行一次二分查找   并且每次出完牌之后需要将该牌删除掉   而数组在删除元素的复杂度为O(n)   因此不适宜直接从小到大进行比较

这道题目可以从大到小进行比较：先将两个数组排序 **(由于打乱了对方的牌堆  所以必须用另外一个容器来装它原来的数组  或者不对它原来的数组进行排序 而是创造出一个新的容器排序)** 

对方的牌堆必须保持原样这是一个难点：

**可以创造出一个哈希表   用来快速查找每一个元素事先乱序的下标   然后对原数组进行排序  再不断比较   注意：在将元素添加到容器中的时候要去哈希表找这个元素之前对应的下标  作为新数组的下标  然后出牌方将它的元素放置到该位置**

那么为什么从大到小进行比较 比它大就直接出牌呢？不是要止损吗？  这是因为如果不直接出牌  而是假设再去比较倒数第二张牌的话 会有两种情况： 1. 倒数第二张牌小于等于对方的牌  那么还是要出原来的牌  这与直接出牌没有区别   2.如果倒数第二张牌大于对方最大的牌  然后出牌获得了胜利  那么出牌方的最大的一张牌用来对付其他的牌一样会获胜   不管怎么出牌获胜的场次都是相等的  所以没有区别



这里是并没有使用哈希表  而是使用了一个保存对组的数组 ：  (明天使用哈希表试一下)

```c++
    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {
        int len = nums1.size();
        vector<int> res(len, -1);
        sort(nums1.begin(), nums1.end());

        vector<pair<int, int>> new_nums2(len);
        for (int i = 0; i < len; ++i) {
            new_nums2[i] = {nums2[i], i};
        }
        
        //排序
        sort(new_nums2.begin(),new_nums2.end(),[](const pair<int,int>& a1,const pair<int,int>& a2){
            return a1.first < a2.first;
        });

        int pnums1 = len - 1;
        int pnums2 = len - 1;
        while (pnums1 >= 0 && pnums2 >= 0) {
            if(nums1[pnums1] > new_nums2[pnums2].first)
                res[new_nums2[pnums2--].second] = nums1[pnums1--];
            else --pnums2;
        }
        if (pnums1 != -1) {
            for(int i = 0; i < len; ++i){
                if(res[i] == -1) res[i] = nums1[pnums1--];
            }
        }
        return res;
    }
```



### 已经试过哈希表了  但是哈希表会有一个问题：就是不能存储元素相同的数  (出现相同的key 后面的元素存不进去)  所以只能使用multimap   但是multimap它解决哈希冲突的方法底层也是使用二叉查找树来实现    因此这道题更适合直接适用能存放相同元素的数组或者使用第二个元素是数组的哈希表  ==>  所以以后碰到会出现哈希冲突的尽量不用哈希表



## 使用multimap

multimap 因为可以存储相同的key   所以它并不能简单的使用类似于读取数组元素的方式读取它的value  (因为它不知道你要读取哪一个)  
