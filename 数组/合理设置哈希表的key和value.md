

| 第一题：[两数之和](https://leetcode.cn/problems/two-sum/) |  🟢   |
| :-------------------------------------------------------: | :--: |
|                                                           |      |



## 合理设置哈希表的key和value

在不同的题目描述中 可能能够想到使用哈希表来解决问题  但是创建哈希表的难点就是要合理地设置它的key值和value值



**例如力扣的第一题两数之和**：给一个无序的数组  求出两个元素的和等于目标值 然后返回两个元素的下标  同时两个元素不能是重复的

设置哈希表要从题目的描述来下手  其中首先是无序的  所以不能使用双指针  只能使用暴力枚举或者是哈希表来做    然后需要返回的是两个元素的下标  因此 哈希表中key或者value的其中一项一定需要存储每一个元素对应的下标值(用于之后返回)   另外一个就要存储元素本身的值了(这一点毋庸置疑  没了元素值还怎么寻找和)     那么让key存储下标还是让value存储下标就是关键了   ==>   因为要求的是两个元素的和  我们就遍历一遍数组   然后**拿数组中的每一个元素检查另一个元素是否存在哈希表中**   如果key来存储下标的话  那么每次查找哈希表中是否存在另一个加数就要将哈希表中每一个元素都遍历一遍才能得知

## **哈希表最重要的就是能够通过key来O(1)地查找一个元素是否存在   所以如果后面需要使用某种元素来查找哈希表的话 那么在创建的时候就要用该种元素作为key**



所以再例如求两数之和2 ： 同样是给定一个无序数组  只需要求出数组中是否存在两数之和为目标值 (不能是重复的元素)    这时候同样需要用数组的元素来查找哈希表中是否存在  所以数组元素应作为key    然后题目没有要求返回元素的下标 所以value不需要存储下标  但是要求不能是重复的元素   因此就可以记录每一个元素出现的次数



## map哈希表的注意事项

如果使用 map[x] 来查找是否存在某个元素的话   如果存在会返回value  如果不存在的话就会创建 {x, 0} 的键值对并返回 0 

