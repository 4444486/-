

## C++11用于随机数的头文件函数

C++STL说明：

1. mt19937头文件是<random> 是伪随机数产生器，用于产生高性能的随机数
2. uniform_int_distribution 头文件在<random>中，是一个随机数分布类，参数为生成随机数的类型，构造函数接受两个值表示区间段
3. accumulate 头文件在<numeric>中，求特定范围内所有元素的和。
4. spartial_sum函数的头文件在<numeric>，对(first, last)内的元素逐个求累计和，放在result容器内
5. back_inserter函数头文件<iterator>，用于在末尾插入元素。
6. lower_bound头文件在<algorithm>，用于找出范围内不小于num的第一个元素



| 牛客网 |                           LeetCode                           |                             力扣                             | 难度 |
| :----: | :----------------------------------------------------------: | :----------------------------------------------------------: | :--: |
|   -    | [528. Random Pick with Weight](https://leetcode.com/problems/random-pick-with-weight/) | [528. 按权重随机选择](https://leetcode.cn/problems/random-pick-with-weight/) |  🟠   |

如何按照不同的权重返回随机数呢？   ==>   这种按不同权重的类似于操作系统中任务调度的彩票问题   即根据彩票的总和  随机选取一个彩票  让拥有该彩票的任务执行

所以当给了一个权重表的时候  第一步就是要计算权重的总和   **但是这里需要注意的是我们仅仅只有每个元素对应的权重  还并没有分配每一个元素占总权重的哪一部分   因此不能只是设置一个变量来存储总权重   否则当生成了一个随机数后如果要按照元素从小到大来占权重比的话   就需要遍历一遍原来的数组  直到找到具体是哪一个元素占了随机数这份权重**

因此可以设置一个权重前缀和数组    这样根据最大的一个元素来随机生成一个数    然后从前缀和数组中找到**正好大于等于**该随机数的下标(该下标减1就是需要返回的元素)   ==>  **虽然这种方法也需要遍历数组查找元素  但不同的是前缀和数组是有序的  只需要二分查找就能快速找到**

顺带一提：C++中随机种子为 srand(time(0)) ：根据时间来生成随机数(在一个程序中只能执行一次！！！ 所以在力扣中就应该放在构造函数中  而在普通的项目中应该放在main函数中)        srand((unsigned)time(0)) ：可以生成无符号数的随机数



## 如果题目要求等概率获取数组  由于rand生成的随机数一定是在某个区间内的   所以底层一定是需要映射到数组的下标中的(求随机数的题目都是需要数组)

