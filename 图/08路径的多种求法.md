

| ç‰›å®¢ |                           LeetCode                           |                             åŠ›æ‰£                             | éš¾åº¦ |
| :--: | :----------------------------------------------------------: | :----------------------------------------------------------: | :--: |
|  -   | [743. Network Delay Time](https://leetcode.com/problems/network-delay-time/) | [743. ç½‘ç»œå»¶è¿Ÿæ—¶é—´](https://leetcode.cn/problems/network-delay-time/) |  ğŸŸ    |
|  -   | [1514. Path with Maximum Probability](https://leetcode.com/problems/path-with-maximum-probability/) | [1514. æ¦‚ç‡æœ€å¤§çš„è·¯å¾„](https://leetcode.cn/problems/path-with-maximum-probability/) |  ğŸŸ    |
|  -   | [1631. Path With Minimum Effort](https://leetcode.com/problems/path-with-minimum-effort/) | [1631. æœ€å°ä½“åŠ›æ¶ˆè€—è·¯å¾„](https://leetcode.cn/problems/path-with-minimum-effort/) |  ğŸŸ    |



## 743

### ä½¿ç”¨Floydç®—æ³•ï¼š(ç”¨äºè®¡ç®—ä»»æ„ä¸¤ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„    ä½¿ç”¨é‚»æ¥çŸ©é˜µå­˜å›¾)

1. åˆ›å»ºäºŒç»´çŸ©é˜µ å¹¶åˆå§‹åŒ–  ä¿å­˜æ‰€æœ‰è¿æ¥é¡¶ç‚¹çš„æƒé‡
2. ç„¶åä¸‰å±‚forå¾ªç¯   è®©æ¯ä¸€ä¸ªé¡¶ç‚¹éƒ½ä½œä¸ºä¸­è½¬é¡¶ç‚¹æ¥éå†å›¾  æ›´æ–°çŸ©é˜µä¸­çš„æƒé‡

```c++
    //é‚»æ¥çŸ©é˜µ
    vector<vector<int>> w;
    int INF = 0x3f3f3f3f;  //è¡¨ç¤ºintçš„æ— ç©·å¤§  å®ƒ+1å¹¶ä¸ä¼šæº¢å‡º æ›´å¸¸ç”¨

    void floyd (int n) {
        //ä¸­è½¬é¡¶ç‚¹--èµ·å§‹é¡¶ç‚¹--ç»ˆç‚¹
        //è¿™ä¸ªå¾ªç¯å¯ä»¥çœ‹æˆä¸¤éƒ¨åˆ† æœ€å¤–é¢ä¸€å±‚æ·»åŠ ä¸­è½¬é¡¶ç‚¹ å’Œé‡Œé¢ä¸¤å±‚å¾ªç¯ä¸€éå›¾ 
        //æ¯æ¬¡éå†ä¸€éå›¾ä¹‹åéƒ½å¤šæ·»åŠ ä¸€ä¸ªä¸­è½¬é¡¶ç‚¹ ä¸€å…±éå†næ¬¡å›¾  æ·»åŠ nä¸ªä¸­è½¬é¡¶ç‚¹å°±èƒ½æ‰¾åˆ° i->j çš„æœ€çŸ­è·¯å¾„
        for(int p = 1; p <= n; ++p) {
            for(int i = 1; i <= n; ++i) {
                for(int j = 1; j <= n; ++j) {
                    w[i][j] = min(w[i][j], w[i][p] + w[p][j]); 
                }
            }
        }
    }

    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        w.resize(n+1);
        for(int i = 1; i <= n; ++i) {
            w[i].resize(n+1);
        }

        //åˆå§‹åŒ–é‚»æ¥çŸ©é˜µ
        for(int i = 1; i <= n; ++i) {
            for(int j = 1; j <= n; ++j) {
                w[i][j] = w[j][i] = i == j ? 0 : INF;  //åˆ°è‡ªèº«çš„è·ç¦»ä¸º0 åˆ°å…¶ä»–é¡¶ç‚¹åˆå§‹åŒ–ä¸ºæ— ç©·
            }
        }

        //è®°å½•é¡¶ç‚¹ä¹‹é—´çš„æƒé‡
        for(auto &item : times) {
            w[item[0]][item[1]] = item[2];
        }

        floyd(n);
		
        //å› ä¸ºçŸ©é˜µä¸­å­˜å‚¨çš„æƒé‡éƒ½æ˜¯åˆ°è¾¾æœ€å°çš„æƒé‡
        //å› æ­¤å¦‚æœè¦æ‰¾åˆ°ä¸€æ¡èƒ½å¤Ÿéå†æ•´å¼ å›¾çš„çº¿è·¯(ä»kå‡ºå‘) é‚£ä¹ˆå°±è¦æ‰¾ä»kå‡ºå‘æœ€é•¿çš„ä¸€æ¡è·¯ ==> éå†åˆ°å°½å¯èƒ½å¤šçš„é¡¶ç‚¹
        //åªè¦kä¸å…¶ä¸­æœ‰ä¸€ä¸ªé¡¶ç‚¹ä¸å¯è¾¾  é‚£ä¹ˆanså°±ä¼šè¢«èµ‹å€¼ä¸ºINF
        int ans = 0;
        for(int i = 1; i <= n; ++i) {
            ans = max(ans, w[k][i]);
        }
        return ans == INF ? -1 : ans;
    }
```



### ä½¿ç”¨é‚»æ¥çŸ©é˜µçš„dijkstal (è®¡ç®—èµ·ç‚¹åˆ°ä»»æ„ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„)

1. åˆ›å»ºäºŒç»´çŸ©é˜µå¹¶åˆå§‹åŒ–  ä¿å­˜é‚»æ¥é¡¶ç‚¹çš„æƒé‡
2. åˆ›å»ºdistæ•°ç»„  åˆå§‹åŒ–ä¸ºæ— ç©·   distä¿å­˜çš„æ˜¯è¯¥é¡¶ç‚¹åˆ°èµ·å§‹é¡¶ç‚¹çš„æ€»è·ç¦»    å› æ­¤distèµ·å§‹ç‚¹åˆå§‹åŒ–ä¸º0
3. åˆ›å»ºä¸€ä¸ªä¸­è½¬è®°å½•æ•°ç»„    æ¯æ¬¡ä»distä¸­å–å‡ºç›®å‰è·ç¦»èµ·ç‚¹æœ€è¿‘çš„ç‚¹   è®©å®ƒä½œä¸ºä¸­è½¬é¡¶ç‚¹æ›´æ–°è·ç¦»(å®ƒæ›´æ–°è·ç¦»åªæ˜¯æ›´æ–°åˆ°èµ·ç‚¹çš„è·ç¦»)  å¹¶**è®°å½•è¯¥ä¸­è½¬é¡¶ç‚¹å·²è¢«éå†(è¿™ä¸€æ­¥å°±æ˜¯dijkstalä¸èƒ½è§£å†³è´Ÿæƒå›¾çš„å…³é”®)**

å¦‚æœ  Bä¼šå…ˆä¸Dä½œä¸ºä¸­è½¬é¡¶ç‚¹è®¿é—®   ç„¶åæ ‡è®°Bå·²è¢«è®¿é—®è¿‡ä¹‹åä¸ä¼šå†ä½œä¸ºä¸­è½¬é¡¶ç‚¹è®¿é—®    ä¹‹åDå¼€å§‹ä½œä¸ºä¸­è½¬é¡¶ç‚¹è¿›è¡Œè®¿é—®  æ­¤æ—¶ä¼šå‘ç°A->D->B çš„è·ç¦»æ¯”ä¹‹å‰çš„ A->B çš„è·ç¦»æ›´å°   æ­¤æ—¶è™½ç„¶ä¼šæ›´æ–°A->Bçš„æœ€å°è·ç¦»  ä½†æ˜¯å¹¶ä¸èƒ½æ›´æ–°A->Cçš„æœ€å°è·ç¦»

æ‰€ä»¥å®ƒä¸èƒ½å¤„ç†è´Ÿæƒå›¾æœ‰ä¸¤ä¸ªå› ç´ ï¼š 1.æœ‰visitedæ•°ç»„çš„å­˜åœ¨      2.æ¯æ¬¡å–é¡¶ç‚¹éƒ½æ˜¯å–è·ç¦»èµ·ç‚¹çš„æœ€å°è·ç¦»  å¹¶ä¸ä¼šè€ƒè™‘ä¹‹åçš„è¾¹

å› æ­¤èƒ½å¤Ÿå¤„ç†è´Ÿæƒå›¾çš„ bellman-ford  å°±æ²¡æœ‰ä½¿ç”¨visitedæ•°ç»„  ==>  æ‰€ä»¥ä¸èƒ½å¤„ç†æœ‰ç¯å›¾   è€Œdijkstalå› ä¸ºvisitedæ•°ç»„çš„å­˜åœ¨å°±èƒ½å¤Ÿå¤„ç†æœ‰ç¯å›¾

```c++
    vector<int> dist;
    vector<bool> vis;
    int INF = 0x3f3f3f3f;
    vector<vector<int>> w;
    
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        w.resize(n+1);
        for(int i = 1; i <= n; ++i) w[i].resize(n+1);

        //åˆå§‹åŒ–äºŒç»´çŸ©é˜µ
        for(int i = 1; i <= n; ++i) {
            for(int j = 1; j <= n; ++j) {
                w[i][j] = w[j][i] = i == j ? 0 : INF;
            }
        }

        //å­˜å…¥æƒé‡  å› ä¸ºæ˜¯æœ‰å‘å›¾ æ‰€ä»¥å­˜å•è¾¹å³å¯
        for(auto &item : times) {
            w[item[0]][item[1]] = item[2];
        }

        dist.resize(n+1, INF); //kç‚¹åˆ°ä»»æ„ç‚¹çš„è·ç¦»éƒ½ä¸ºæ— ç©·
        vis.resize(n+1, false);
        dijkstra(n, k);    

        //åŒæ ·æ‰¾æœ€é•¿çš„ä¸€æ¡è·¯å¾„
        int ans = 0;
        for(int i = 1; i <= n; ++i) {
            ans = max(ans, dist[i]);
        }

        //ansç­‰äºINFè¯´æ˜è‡³å°‘æœ‰ä¸€ä¸ªé¡¶ç‚¹ä¸å¯è¾¾
        return ans == INF ? -1 : ans;
    }

    void dijkstra (int n, int k) {
        dist[k] = 0;  //kåˆ°è‡ªå·±çš„è·ç¦»ä¸º0

        for(int p = 1; p <= n; ++p) {

            //æ‰¾åˆ°ç¦»kç‚¹è·ç¦»æœ€å°çš„ç‚¹t  å¹¶ä¸”è¦æœªåšè¿‡ä¸­è½¬é¡¶ç‚¹çš„
            int t = -1;
            for(int i = 1; i <= n; ++i) {
                if(!vis[i] && (t == -1 || dist[i] < dist[t])) t = i;
            }

            if(t == -1) return;

            vis[t] = true;
            //åˆ©ç”¨té¡¶ç‚¹ä½œä¸ºä¸­è½¬ç‚¹æ¥æ›´æ–°è·ç¦»
            for(int i = 1; i <= n; ++i) {
                dist[i] = min(dist[i], dist[t] + w[t][i]);
            }
        }
    }
```



### ä½¿ç”¨é‚»æ¥è¡¨å®ç°dijkstalå•ç‚¹åˆ°å¤šç‚¹çš„æœ€çŸ­è·¯å¾„

```c++
class Compare{
    public:
        bool operator() (pair<int, int> &a, pair<int, int> &b) {
            return a.second > b.second;
        }
};

class Solution {
public:
    vector<vector<pair<int, int>>> graph;
    vector<int> dist;
    int INF = 0x3f3f3f3f;
    vector<bool> vis;

    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        graph.resize(n+1);
        for(auto &item : times) {
            int from = item[0], to = item[1], cost = item[2];
            graph[from].push_back({to, cost});
        }

        dist.resize(n+1, INF);
        dist[k] = 0;
        vis.resize(n+1, false);
        dijkstra(n, k);

        //ä»distä¸­æ‰¾åˆ°æœ€å¤§çš„ä¸€ä¸ªè·ç¦»
        int ans = 0;
        for(int i = 1; i <= n; ++i) {
            ans = max(ans, dist[i]);
        }
        return ans == INF ? -1 : ans;
    }

    void dijkstra (int n, int k) {
        //åˆ›å»ºä¸€ä¸ªå°é¡¶å † å¿«é€Ÿå¾—åˆ°distä¸­çš„æœ€å°å€¼
        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;
        pq.push({k, 0});

        while(pq.empty() == false) {
            auto[to, cost] = pq.top(); pq.pop();

            if(vis[to]) continue;

            vis[to] = true;
            //å°†toé¡¶ç‚¹ç›¸é‚»çš„è¾¹åŠ å…¥åˆ°é˜Ÿåˆ—ä¸­
            for(auto &item : graph[to]) {
                if(dist[item.first] > dist[to] + item.second) dist[item.first] = dist[to] + item.second;
                pq.push({item.first, dist[item.first]});
            }
        }
    }
};
```



### é“¾å¼å‰å‘æ˜Ÿå­˜å‚¨å›¾

ä¸€å…±éœ€è¦å››ä¸ªæ•°ç»„ï¼šhead è®°å½•ä»¥ä¸‹æ ‡ä½œä¸ºå¤´èŠ‚ç‚¹çš„æœ€åä¸€æ¡è¾¹çš„ç¼–å· ä¾‹å¦‚ head[1] ï¼š1å°±æ˜¯é¡¶ç‚¹ç¼–å·  head[1]å®ƒå…¶ä¸­ä¸€æ¡è¾¹çš„ç¼–å·    to è®°å½•è¯¥è¾¹æŒ‡å‘çš„é¡¶ç‚¹ç¼–å·  w è®°å½•æ”¹å˜çš„æƒé‡   next è®°å½•è¯¥è¾¹çš„ä¸Šä¸€æ¡è¾¹çš„ç¼–å· (å› ä¸ºå®ƒæ˜¯å¤´æ’æ³•) 

```c++
class Solution {
public:
    int *head, *t, *w, *next;  //å››ä¸ªæ•°ç»„ é“¾å¼å‰å‘æ˜Ÿ
    int idx = 1;
    vector<bool> vis;
    vector<int> dist;
    int INF = 0x3f3f3f3f;

    void add (int from, int to, int cost) {
        w[idx] = cost;
        t[idx] = to;
        next[idx] = head[from]; //æŒ‡å‘ä¸Šä¸€æ¡åŒèµ·ç‚¹çš„è¾¹
        head[from] = idx;  //headæŒ‡å‘æœ€åä¸€æ¡è¾¹
        ++idx;  //è¾¹çš„ç¼–å·+1
    }

    void dijkstra (int n, int k) {

        dist[k] = 0;
        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;
        pq.push({k, 0});

        while(pq.empty() == false) {
            auto[to, cost] = pq.top(); pq.pop();
            if(vis[to]) continue;  //å¼¹å‡ºæ¥çš„æ”¹å˜çš„ç»ˆç‚¹å·²ç»éå†è¿‡äº† è¯´æ˜ä¹‹å‰æœ‰æ›´çŸ­çš„è·¯å¾„åˆ°è¾¾å®ƒ å°±å¯ä»¥èˆå¼ƒè¯¥è¾¹äº†

            vis[to] = true;
            //headæŒ‡å‘ä»¥toä¸ºå¤´é¡¶ç‚¹çš„æœ€åä¸€æ¡è¾¹çš„ç¼–å· å³éå†toå‘¨å›´çš„é¡¶ç‚¹
            for(int i = head[to]; i != -1; i = next[i]) {
                int j = t[i];
                if(dist[j] > dist[to] + w[i]) {
                    dist[j] = dist[to] + w[i];
                    pq.push({j, dist[j]});
                }
            }
        }
    }

    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        int nums = times.size();

        //è®©headåˆå§‹å€¼ä¸º-1  è¿™æ ·å°±èƒ½ä½¿å¾—æœ€åä¸€æ¡è¾¹çš„nextæŒ‡å‘-1
        head = new int[110];
        //å‰©ä¸‹ä¸‰ä¸ªæ•°ç»„çš„é•¿åº¦ä¸è¾¹æ•°ç›®æœ‰å…³
        t = new int[6010]; w = new int[6010]; next = new int[6010];
        fill(head, head+110, -1);

        for(auto &item : times) {
            int from = item[0], to = item[1], cost = item[2];
            add(from, to, cost);
        }

        dist.resize(n+1, INF);
        vis.resize(n+1, false);

        dijkstra(n, k);

        int ans = 0;
        for(int i = 1; i <= n; ++i) {
            ans = max(ans, dist[i]);
        }
        return ans == INF ? -1 : ans;
    }
};
```



### bellman-ford(èƒ½å¤Ÿå¤„ç†è´Ÿæƒå€¼)

ç»è¿‡ä¸Šé¢çš„åˆ†æ  bellman-ford ä¸èƒ½ä½¿ç”¨visitedæ•°ç»„æ¥é™åˆ¶éå†çš„èŠ‚ç‚¹  

å®ƒä¸»è¦çš„å®ç°åŸç†å°±æ˜¯    ä»ç¼–å·1ä¸€ç›´å¾ªç¯åˆ°ç¼–å·n   ç„¶åå¯¹å®ƒä»¬è¿›è¡Œæ‰©æ•£(ä½œä¸ºä¸­è½¬ç«™)    **è¿™ä¸ªæ“ä½œå®ç°v-1æ¬¡å°±èƒ½å¤Ÿå®ç°ç»è¿‡v-1æ¡è¾¹ åˆ°è¾¾ä»»æ„é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„   å› ä¸ºä¸€å¼ å›¾ä¸­éšæœºå–ä¸€ä¸ªç‚¹  åˆ°è¾¾ä»»æ„ä¸€ä¸ªç‚¹æœ€å¤šç»è¿‡v-1æ¡è¾¹(æ— ç¯)     æ‰€ä»¥æœ€å¤–å±‚å¾ªç¯å®é™…ä¸Šå°±æ˜¯èµ·å§‹é¡¶ç‚¹åˆ°å…¶ä»–é¡¶ç‚¹çš„è¾¹æ•°**  

### **å³ ç¼–å·1çš„é¡¶ç‚¹åˆ°ç¼–å·2çš„é¡¶ç‚¹å¯èƒ½æœ€çŸ­èµ°ä¸¤æ¡è·¯å°±åˆ°äº†  ä½†æ˜¯æˆ‘ä»¬éœ€è¦è®©å®ƒèµ°å°½å¯èƒ½å¤šçš„è·¯  ä»ä¸­é€‰æ‹©æœ€çŸ­çš„é‚£ä¸€æ¡è·¯å¾„  åªè¦è®©å®ƒèµ°v-1æ¡è·¯  é‚£ä¹ˆå°±èƒ½å®ç°ç»è¿‡å…¶ä»–æ‰€æœ‰çš„é¡¶ç‚¹å†åˆ°è¾¾é¡¶ç‚¹2  è¿™æ ·å°±èƒ½ç¡®ä¿é€‰å‡ºæ¥çš„æƒé‡å’Œæ˜¯æœ€å°çš„**

```c++
	void bellman (int n, int k) {

        dist[k] = 0;
		
        //éœ€è¦å¯¹æ¯ä¸€ä¸ªé¡¶ç‚¹è¿›è¡Œv-1æ¬¡æ¾å¼›æ“ä½œ è¿™æ ·æ‰èƒ½ç¡®ä¿å®ƒèƒ½å¤Ÿéå†å®Œæ•´ä¸ªå›¾ä¸Šçš„æ‰€æœ‰é¡¶ç‚¹ åŒæ—¶èƒ½å¤Ÿä¿è¯åˆ°è¾¾ä»»æ„é¡¶ç‚¹çš„æƒå€¼æœ€ä½
        //å› ä¸ºå®ƒå†…å±‚çš„æ¾å¼›æ“ä½œæ˜¯æŒ‰ç…§èŠ‚ç‚¹çš„ç¼–å·è¿›è¡Œçš„  æ‰€ä»¥æœ‰å¯èƒ½åœ¨å¯¹å°ç¼–å·çš„dç‚¹è¿›è¡Œæ¾å¼›æ“ä½œæ—¶å®ƒçš„distè¿˜ä¸ºæ­£æ— ç©· è¿™æ—¶å€™å®ƒæ— æ³•æ›´æ–°ä»»ä½•çš„è¾¹æƒé‡
        //å³è¿™æ¬¡éå†æ•´å¼ å›¾æ—¶è®¡ç®—çš„æƒå€¼å’Œå¹¶æ²¡æœ‰åŒ…å«å°ç¼–å·çš„é¡¶ç‚¹  
        //å› æ­¤åªè¦å¾ªç¯v-1æ¬¡ å°±èƒ½ä¿è¯è®¡ç®—æƒå€¼å’Œèƒ½å¤Ÿä½¿æ‰€æœ‰çš„ç‚¹éƒ½è¿›è¡Œäº†æµ‹è¯•
        for(int i = 1; i < n; ++i) {
            vector<int> prev = dist;
            for(int a = 1; a <= n; ++a) {
                for(int b = head[a]; b != -1; b = next[b]) {
                    int to = t[b];
                    if(dist[to] > prev[a] + w[b]) dist[to] = prev[a] + w[b];
                }
            }
        }
    }
```

bellman-ford è¿˜èƒ½å¤Ÿæ¢æµ‹å›¾ä¸­æ˜¯å¦æœ‰è´Ÿæƒç¯ï¼šå°±æ˜¯å®ƒåœ¨å¾ªç¯å®Œäº†v-1æ¬¡å   å†è¿›è¡Œä¸€æ¬¡å…¨å›¾çš„æ¾å¼›æ“ä½œ   å¦‚æœè¿˜èƒ½å¤Ÿæ¾å¼›  è¯´æ˜æœ‰è´Ÿæƒç¯



### SPFAä¼˜åŒ–bellman

åœ¨æ­¤ä¹‹å‰è¦ç†è§£ï¼šbellmanå®ƒæ—¶é—´å¤æ‚åº¦é«˜çš„åŸå› æœ‰ä»€ä¹ˆï¼Ÿä¸dijkstalçš„åŒºåˆ«åœ¨å“ªï¼Ÿ

å®ƒä¸dijkstalçš„åŒºåˆ«æ˜¯ dijkstal å®ƒæœ‰visitedæ•°ç»„  åªè¦è®¾ç½®ä¸ºtrue  é‚£ä¹ˆåç»­çš„é¡¶ç‚¹å°½ç®¡æœ‰æ›´çŸ­çš„è·¯å¾„è¾¾åˆ°è¯¥é¡¶ç‚¹   éƒ½ä¸ä¼šç”¨è¯¥é¡¶ç‚¹è¿›è¡Œé‡æ–°æ‰©æ•£   æ‰€ä»¥å®ƒæ¯ä¸€ä¸ªé¡¶ç‚¹æœ€å¤šç”¨æ¥æ‰©æ•£ä¸€æ¬¡     è€Œbellmanæ¯ä¸€ä¸ªé¡¶ç‚¹å›ºå®šéƒ½æœ€å°‘è¦æ‰©æ•£v-1æ¬¡ (ä½†æ˜¯å¤§éƒ¨åˆ†çš„æƒ…å†µéƒ½ä¸éœ€è¦æ‰©æ•£é‚£ä¹ˆå¤šæ¬¡  æ‰€ä»¥SPFAå°±åœ¨ä¼˜åŒ–è¿™ä¸€æ­¥)

**é‚£ä¹ˆè¯¥å¦‚ä½•é˜»æ­¢å®ƒä¸å¾ªç¯é‚£ä¹ˆå¤šæ¬¡å‘¢ï¼Ÿ  å¯ä»¥è®¾ç½®ä¸€ä¸ªé˜Ÿåˆ—  æ¯æ¬¡å¼¹å‡ºä¸€ä¸ªé¡¶ç‚¹   è®©å®ƒæ¾å¼›ç›¸é‚»çš„é¡¶ç‚¹  å¦‚æœæ¾å¼›æˆåŠŸäº†(é‚£ä¹ˆä»é‚£ä¸ªæ¾å¼›æˆåŠŸçš„ç‚¹å‡ºå‘å°±å¯ä»¥å‡ºç°è¾¾åˆ°å…¶ä»–é¡¶ç‚¹çš„è·ç¦»å˜å°)   åˆ™è®©ç›¸é‚»çš„é¡¶ç‚¹å…¥é˜Ÿ  è¿™æ ·åªè¦å®ƒè¿ç»­å‡ ä¸ªé¡¶ç‚¹éƒ½æ¾å¼›å¤±è´¥çš„è¯  é˜Ÿåˆ—å¾ˆå¿«å°±ä¼šä¸ºç©º(å…·ä½“å€¼ä¸ç¡®å®š)  åªè¦é˜Ÿåˆ—ä¸ºç©ºå°±é€€å‡ºå¾ªç¯  **     

åªè¦å®ƒèƒ½å¤Ÿæ¾å¼›æˆåŠŸ é˜Ÿåˆ—å°±ä¸ä¼šä¸ºç©º  æ‰€ä»¥å°±ä¸å¯èƒ½å‡ºç°è¿˜æ²¡éå†å®Œé˜Ÿåˆ—å°±ä¸ºç©ºçš„æƒ…å†µ 

**æ—¶é—´å¤æ‚åº¦é€€åŒ–çš„æƒ…å†µï¼šä¹Ÿå°±æ˜¯ç½‘æ ¼çŠ¶   æ‰€æœ‰çš„é¡¶ç‚¹éƒ½æ˜¯è¿é€šçš„   è€Œè¿™æ—¶å€™è´Ÿæƒå€¼çš„è·¯å¾„å°±æœ‰å¯èƒ½ä¼šå‡ºç°åŒä¸€ä¸ªé¡¶ç‚¹ä¸åœåœ°å…¥é˜Ÿå’Œå‡ºé˜Ÿ  å› ä¸ºä»»æ„çš„é¡¶ç‚¹éƒ½æ˜¯ç›¸é€šçš„**

```c++
    void spfa (int n, int k) {

        dist[k] = 0;
        
        queue<int> q; //ä½¿ç”¨é˜Ÿåˆ— å­˜å‚¨é¡¶ç‚¹çš„ç¼–å·
        q.push(k);
        vis[k] = true;
        while(q.empty() == false) {
            int cur = q.front(); q.pop();
            vis[cur] = false;
            for(int i = head[cur]; i != -1; i = next[i]) {
                int j = t[i];
                if(dist[j] > dist[cur] + w[i]) {
                    dist[j] = dist[cur] + w[i];
                    if(vis[j]) continue;  //ä¸éœ€è¦é‡å¤å…¥é˜Ÿ
                    q.push(j);
                    vis[j] = true;
                }
            }
        }
    }
```

