

## Kruskal ==>  ä½¿ç”¨åˆ°äº†å¹¶æŸ¥é›†   æ¯æ¬¡å–å‡ºå‰©ä½™è¾¹çš„æœ€å°æƒé‡  åˆ¤æ–­ä¸¤ä¸ªé¡¶ç‚¹æ˜¯å¦å·²ç»è¿é€š(å¹¶æŸ¥é›†)

| ç‰›å®¢ |                           LeetCode                           |                             åŠ›æ‰£                             | éš¾åº¦ |
| :--: | :----------------------------------------------------------: | :----------------------------------------------------------: | :--: |
|  -   | [261. Graph Valid Tree](https://leetcode.com/problems/graph-valid-tree/)ğŸ”’ | [261. ä»¥å›¾åˆ¤æ ‘](https://leetcode.cn/problems/graph-valid-tree/)ğŸ”’ |  ğŸŸ    |
|  -   | [1135. Connecting Cities With Minimum Cost](https://leetcode.com/problems/connecting-cities-with-minimum-cost/)ğŸ”’ | [1135. æœ€ä½æˆæœ¬è”é€šæ‰€æœ‰åŸå¸‚](https://leetcode.cn/problems/connecting-cities-with-minimum-cost/)ğŸ”’ |  ğŸŸ    |
|  -   | [1584. Min Cost to Connect All Points](https://leetcode.com/problems/min-cost-to-connect-all-points/) | [1584. è¿æ¥æ‰€æœ‰ç‚¹çš„æœ€å°è´¹ç”¨](https://leetcode.cn/problems/min-cost-to-connect-all-points/) |  ğŸŸ    |



## æœ€ä½æˆæœ¬è¿é€šæ‰€æœ‰åŸå¸‚

```c++
    int minimumCost(int n, vector<vector<int>>& connections) {
        //å°†è¾¹æŒ‰ç…§æƒé‡å¤§å°è¿›è¡Œæ’åº
        sort(connections.begin(), connections.end(), [](vector<int> &v1, vector<int> &v2){
            return v1[2] < v2[2];
        });

        int count = 0;
        UnionFind uf(n+1); //å› ä¸ºæ˜¯ä»1å¼€å§‹ç¼–å·
        for(auto &item : connections) {
            if(uf.Connects(item[0], item[1])) continue; //å¿½ç•¥è¯¥è¾¹

            count += item[2];
            uf.Union(item[0], item[1]);
        }
        
        //å› ä¸ºåˆ›å»ºå¹¶æŸ¥é›†çš„æ—¶å€™å¤šäº†ä¸€ä¸ª0 æ‰€ä»¥0é¡¶ç‚¹ä¸€å®šæ˜¯å•ç‹¬çš„
        return uf.Count() == 2 ? count : -1;
    }
```





## Prim å°†é¡¶ç‚¹çœ‹ä½œæ˜¯ç‹¬ç«‹çš„  ç„¶åè®©å®ƒä¸å‰©ä¸‹ç›¸é‚»çš„é¡¶ç‚¹è¿æ¥(æ‰¾æƒé‡æœ€å°çš„ä¸€æ¡è¾¹)

æ‰¾åˆ°æƒé‡æœ€å°çš„ä¸€æ¡è¾¹åå¦‚æœç›®æ ‡é¡¶ç‚¹å·²ç»å¤„äºé›†åˆä¸­  é‚£ä¹ˆå°±æŠ›å¼ƒè¯¥é¡¶ç‚¹  æ‰¾æƒé‡ç¬¬äºŒå°çš„    ç›´åˆ°æ‰€æœ‰çš„é¡¶ç‚¹éƒ½å¤„äºé›†åˆä¸­   åˆ™æœ€å°æ ‘å·²ç»ç”Ÿæˆå¥½

æ‰€ä»¥è¦ä¸€ä¸ªvisitedæ•°ç»„ è®°å½•é¡¶ç‚¹æ˜¯å¦åœ¨é›†åˆä¸­(ä¹Ÿå¯ä»¥ä½¿ç”¨unordered_setæ¥ä»£æ›¿)

**ç”±äºè¿™æ˜¯åŠ æƒæ— å‘å›¾   æ‰€ä»¥åœ¨åˆ›å»ºé‚»æ¥è¡¨çš„æ—¶å€™ç¬¬äºŒç»´ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªäºŒå…ƒç»„  éœ€è¦å­˜å‚¨æƒé‡   å¹¶ä¸”åœ¨åˆ›å»ºè¡¨çš„æ—¶å€™ä¸èƒ½å¿˜è®°ä¸¤ä¸ªé¡¶ç‚¹éƒ½æ·»åŠ ç›¸åº”çš„è®°å½•**



```c++
class Compare{
    public:
        bool operator () (pair<int, int> &a, pair<int, int> &b) {
            return a.second > b.second;
        }
};

class Prim {
public:
    //äºŒå…ƒç»„ {to, weight}
    priority_queue<pair<int,int>, vector<pair<int,int>>, Compare> pq;

    int weight;
    vector<bool> inSet; //è®°å½•é¡¶ç‚¹æ˜¯å¦å·²ç»åœ¨æœ€å°æ ‘ä¸­
    
    //from:{to, cost}; 
    vector<vector<pair<int, int>>> edges;


    Prim (vector<vector<pair<int, int>>> &graph) {
        weight = 0;
        inSet.resize(graph.size(), false);
        edges = graph;

        int n = graph.size();  //é¡¶ç‚¹æ•°

        //ä»é¡¶ç‚¹0å¼€å§‹åˆ‡åˆ†
        inSet[0] = true;
        cut(0);  
        
        while(pq.empty() == false) {
            auto [to, cost] = pq.top(); pq.pop();

            //åˆ¤æ–­è¾¹çš„é¡¶ç‚¹æ˜¯å¦å·²ç»åœ¨é›†åˆä¸­ å·²ç»åœ¨çš„è¯è¿˜æ·»åŠ è¯¥è¾¹å°±ä¼šå½¢æˆç¯
            if(inSet[to]) continue;

            weight += cost;
            inSet[to] = true;

            cut(to); //åœ¨å°†toé¡¶ç‚¹çš„ç›¸é‚»çš„è¾¹éƒ½åŠ å…¥æœ€å°å †
        }
    }

    //å°†é¡¶ç‚¹0ç›¸æ¥çš„è¾¹åŠ å…¥åˆ°æœ€å°å †ä¸­
    void cut (int n) {
        //æ˜¯ä¸€ä¸ªäºŒå…ƒç»„æ•°ç»„
        for(auto &item : edges[n]) {

            //è¦åˆ¤æ–­æ˜¯å¦åœ¨é›†åˆä¸­
            if(inSet[item.first]) continue;

            pq.push(item);
        }
    }

    int getWeight () {
        return weight;
    }

    //åˆ¤æ–­æ‰€æœ‰é¡¶ç‚¹æ˜¯å¦éƒ½ç›¸è¿
    bool allConnected () {
        for(auto item : inSet) {
            if(item == false) return false;
        }
        return true;
    }
};

class Solution {
public:
    int minimumCost(int n, vector<vector<int>>& connections) {
        vector<vector<pair<int ,int>>> graph(n);
        //å»ºä¸€ä¸ªå¸¦æœ‰æƒé‡çš„è¡¨
        for(auto &item : connections) {
            int from = item[0] - 1, to = item[1] - 1, cost = item[2];
            graph[from].push_back({to, cost}); //ä¸èƒ½ä½¿ç”¨emplace_back
            graph[to].push_back({from, cost});
        }

        //åˆ›å»ºPrim
        Prim prim(graph);

        return prim.allConnected() == true ? prim.getWeight() : -1;
    }

};
```

