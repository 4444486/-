

| 牛客 |                           LeetCode                           |                             力扣                             | 难度 |
| :--: | :----------------------------------------------------------: | :----------------------------------------------------------: | :--: |
|  -   | [277. Find the Celebrity](https://leetcode.com/problems/find-the-celebrity/)🔒 | [277. 搜寻名人](https://leetcode.cn/problems/find-the-celebrity/)🔒 |  🟠   |



## 名流问题

因为要频繁的查询两个顶点之间的是否连通的关系  所以需要使用邻接矩阵

由于题目中已经给出了人数n  因此不需要额外创建二维数组



名流问题最重要的一个特征就是：名流不能认识其他任何人     ==>  因此可以使用排除法    **随便取两个人：如果A不认识B  那么B就不是名流   如果A认识B  那么A就不是名流 **     从0~n开始遍历  假设0是名流  在遍历的过程中 0不认识的人一定不是名流   如果出现0认识一个人  那么0就不是名流  那个0认识的人可能是名流  然后判断该人是否认识其他人  这时候可以接着后面继续遍历    ==>  一共遍历n次就能确定一个名流候选人(只有它可能是名流)

因为刚才判断的是名流不认识其他后续遍历的人  并没有判断其他人是否认识名流 或者是 名流是否认识前面遍历的人

因此还要进行一次n循环    如果出现该候选人认识其他人  或者 其他有人不认识该候选人     那么在场所有人就没有名流

```c++
    int findCelebrity(int n) {
        int i = 0;
        int j;
        for(j = 1; j < n; ++j) {
            if(knows(i, j)) i = j;
        }

        for(j = 0; j < n; ++j) {
            if( (knows(i, j) && i != j) || !knows(j, i)) return -1;
        }

        return i;
    }
```

