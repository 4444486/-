

| ç‰›å®¢ |                           LeetCode                           |                             åŠ›æ‰£                             | éš¾åº¦ |
| :--: | :----------------------------------------------------------: | :----------------------------------------------------------: | :--: |
|  -   | [785. Is Graph Bipartite?](https://leetcode.com/problems/is-graph-bipartite/) | [785. åˆ¤æ–­äºŒåˆ†å›¾](https://leetcode.cn/problems/is-graph-bipartite/) |  ğŸŸ    |
|  -   | [886. Possible Bipartition](https://leetcode.com/problems/possible-bipartition/) | [886. å¯èƒ½çš„äºŒåˆ†æ³•](https://leetcode.cn/problems/possible-bipartition/) |  ğŸŸ    |



## å›ºå®šèµ·ç‚¹çš„å›æº¯  ä¸ ä¸å›ºå®šçš„å›æº¯

å¦‚æœæ˜¯å›ºå®šäº†èµ·ç‚¹çš„å›æº¯  é‚£ä¹ˆå°±å¯ä»¥å¯¹èŠ‚ç‚¹è¿›è¡Œå›æº¯        å¦‚æœä¸å›ºå®šèµ·ç‚¹  é‚£ä¹ˆå°±å¯ä»¥å¯¹è·¯å¾„è¿›è¡Œå›æº¯

å›æº¯çš„forå¾ªç¯å°±ç±»ä¼¼äºåœ¨å¤šå‰æ ‘ä¸­**å¯»æ‰¾ä¸€æ¡è·¯å¾„**å‘ä¸‹é€’å½’   æ³¨æ„è¿™ä¸ªforå¾ªç¯ä¸æ˜¯å¯»æ‰¾èŠ‚ç‚¹

è€Œå›æº¯å‡½æ•°ç®—æ˜¯æ¸¸èµ°åœ¨å¤šå‰æ ‘ä¸Šçš„æŒ‡é’ˆ  forå¾ªç¯é‡Œé¢å†™å›æº¯å‡½æ•°å°±ç›¸å½“äºå°†æŒ‡é’ˆæŒ‡å‘äº†ä¸‹ä¸€å±‚çš„èŠ‚ç‚¹

### å›æº¯ä¸€äº›å‰ªæçš„ä½ç½®ï¼š

**å¦‚æœå°†å‰ªæåˆ¤æ–­å†™åœ¨forå¾ªç¯çš„å¤–é¢   å°±ç›¸å½“äºæ˜¯å¯¹èŠ‚ç‚¹è¿›è¡Œåˆ¤æ–­  è€Œéè·¯å¾„     å¦‚æœå†™åœ¨forå¾ªç¯çš„é‡Œé¢  é‚£ä¹ˆå°±æ˜¯å¯¹è·¯å¾„çš„é€‰æ‹©è¿›è¡Œåˆ¤æ–­**



## äºŒåˆ†å›¾çš„åˆ¤æ–­

DFSï¼š

```c++
    bool isBinaryGraph = true;
    vector<bool> visited;
    vector<bool> color;

    bool isBipartite(vector<vector<int>>& graph) {
        visited.resize(graph.size(), false);
        color.resize(graph.size(), false);

        for(int i = 0; i < graph.size(); ++i) {
            //è¿™é‡Œçš„åˆ¤æ–­åªæ˜¯ç”¨æ¥å‰ªææ“ä½œ  m
            if(visited[i] == false)
                traverse(graph, i);
        }

        return isBinaryGraph;
    }

    void traverse (vector<vector<int>> &graph, int s) {
        if(isBinaryGraph == false) return;

        visited[s] = true;
        for(auto &item : graph[s]) {
            //å¦‚æœè¯¥èŠ‚ç‚¹æ²¡æœ‰è¢«è®¿é—®è¿‡ åˆ™å°†å®ƒç€è‰²
            if(!visited[item]) {
                color[item] = !color[s];  //ä¸sé¡¶ç‚¹é¢œè‰²ç›¸å
                traverse(graph, item);
            }
            else {
                //å¦‚æœè¢«è®¿é—®è¿‡ åˆ™åˆ¤æ–­æ˜¯å¦ç¬¦åˆäºŒåˆ†å›¾
                if(color[item] == color[s]) isBinaryGraph = false;
            }
        }
    }
```

BFSï¼š

```c++
    bool isBinaryGraph = true;
    vector<bool> color;
    vector<bool> visited;

    bool isBipartite(vector<vector<int>>& graph) {
        color.resize(graph.size(), false);
        visited.resize(graph.size(), false);

        //ç”±äºæ²¡æœ‰å›ºå®šèµ·ç‚¹ æ‰€ä»¥ä½¿ç”¨forå¾ªç¯
        for(int i = 0; i < graph.size(); ++i) {
            if(visited[i] == false) bfs(graph, i);
        }

        return isBinaryGraph;
    }

    void bfs (vector<vector<int>> &graph, int start) {
        queue<int> q;
        q.emplace(start);
        visited[start] = true;

        //åªè¦ä¸æ˜¯äºŒåˆ†å›¾å°±ä¸éœ€è¦ç»§ç»­å¾ªç¯äº†
        while(q.empty() == false && isBinaryGraph) {
            int cur = q.front(); q.pop();
            //ç„¶åè¿›è¡Œæ‰©æ•£
            for(auto &item : graph[cur]) {
                if(!visited[item]) {
                    color[item] = !color[cur];
                    visited[item] = true;
                    q.emplace(item);
                }
                else{
                    if(color[item] == color[cur]) isBinaryGraph = false;
                }
            }
        }
    }
```



å¹¶æŸ¥é›†è§£å†³äºŒåˆ†å›¾ï¼š

å› ä¸ºè¿™æ˜¯é›†åˆé—®é¢˜  å¹¶ä¸”ä¸€å¼ å›¾æœ€å¤šæœ‰ä¸¤ä¸ªé›†åˆ ==>  ä¸€ä¸ªé¡¶ç‚¹ä¸å®ƒç›¸é‚»çš„é¡¶ç‚¹ä¸èƒ½åœ¨åŒä¸€ä¸ªé›†åˆä¸­ 

```c++
    bool isBipartite(vector<vector<int>>& graph) {
        int n = graph.size();
        UnionFind uf(n);
        for(int i = 0; i < n; ++i) {
            vector<int> v = graph[i];
            for(int vertex : v) {
                if(uf.isConnected(i, vertex)) return false; //å¦‚æœé¡¶ç‚¹ä¸å®ƒç›¸é‚»çš„ç‚¹å¤„åœ¨åŒä¸€ä¸ªé›†åˆå°±ä¸æ˜¯äºŒåˆ†å›¾

                uf.unio(v[0], vertex); //è®©å®ƒæ‰€æœ‰ç›¸é‚»çš„é¡¶ç‚¹éƒ½åˆå¹¶
            }
        }
        return true;
    }
```

