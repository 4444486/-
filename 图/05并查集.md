

| ç‰›å®¢ |                           LeetCode                           |                             åŠ›æ‰£                             | éš¾åº¦ |
| :--: | :----------------------------------------------------------: | :----------------------------------------------------------: | :--: |
|  -   | [130. Surrounded Regions](https://leetcode.com/problems/surrounded-regions/) | [130. è¢«å›´ç»•çš„åŒºåŸŸ](https://leetcode.cn/problems/surrounded-regions/) |  ğŸŸ    |
|  -   | [323. Number of Connected Components in an Undirected Graph](https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/)ğŸ”’ | [323. æ— å‘å›¾ä¸­è¿é€šåˆ†é‡çš„æ•°ç›®](https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/)ğŸ”’ |  ğŸŸ    |
|  -   | [990. Satisfiability of Equality Equations](https://leetcode.com/problems/satisfiability-of-equality-equations/) | [990. ç­‰å¼æ–¹ç¨‹çš„å¯æ»¡è¶³æ€§](https://leetcode.cn/problems/satisfiability-of-equality-equations/) |  ğŸŸ    |



## åˆ¤æ–­æ— å‘å›¾è¿é€šåˆ†é‡çš„æ•°ç›®

1.DFS

```c++
    vector<bool> visited;

    int countComponents(int n, vector<vector<int>>& edges) {
        vector<vector<int>> graph(n);
        for(auto &item : edges) {
            int vertex1 = item[0], vertex2 = item[1];
            graph[vertex1].emplace_back(vertex2);
            graph[vertex2].emplace_back(vertex1);
        }

        visited.resize(n, false);
        
        int count = 0;
        for(int i = 0; i < n; ++i) {
            if(!visited[i]) {
                ++count;  //åœ¨æ­¤å¤„è®°å½•åŠ 1å³å¯
                dfs(graph, i);
            }
        }
        return count;
    }

    void dfs (vector<vector<int>> &graph, int s) {
        visited[s] = true;
        for(auto &item : graph[s]) {
            if(!visited[item]) 
                dfs(graph, item);
        }
    }
```



2.å¹¶æŸ¥é›†

```c++
class UnionFind {
public:
    int count;
    vector<int> parent; //å­˜å‚¨æ¯ä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘çš„çˆ¶èŠ‚ç‚¹

    UnionFind (int n):count(n) {
        for(int i = 0; i < n; ++i) {
            parent.emplace_back(i);  //ä¸€å¼€å§‹éƒ½æŒ‡å‘è‡ªèº«
        }
    }

    //å°†p qæ‰€åœ¨çš„ä¸¤ä¸ªé›†åˆè¿›è¡Œåˆå¹¶
    void Union (int p, int q) {
        if(Connects(p, q)) return;

        parent[parent[p]] = q;  //è®©pé›†åˆæ¥åˆ°qé›†åˆçš„ä¸‹é¢(æ³¨æ„æ˜¯è®©pçš„çˆ¶èŠ‚ç‚¹æ¥è¿‡å» ä¸æ˜¯å®ƒè‡ªå·±æ¥è¿‡å»)
        --count;
    }

    //åˆ¤æ–­æ˜¯å¦è¿é€š
    bool Connects (int i, int j) {
        return Find(i) == Find(j);
    }
    
    //è¿”å›å®ƒçš„çˆ¶èŠ‚ç‚¹
    int Find (int index) {  
        //åœ¨æŸ¥æ‰¾çš„æ—¶å€™è¿›è¡Œè·¯å¾„å‹ç¼©
        if(parent[index] != index) {
            parent[index] = Find(parent[index]);
        }

        return parent[index];
    }

    int Count () {
        return count;
    }
};

class Solution {
public:
    int countComponents(int n, vector<vector<int>>& edges) {
        UnionFind uf(n); //å…ˆåˆ›å»ºå¹¶æŸ¥é›†

        //å¯¹æ‰€æœ‰å‘è¿æ¥çš„èŠ‚ç‚¹è¿›è¡Œåˆå¹¶ ç„¶åè¿”å›countå³å¯
        for(auto &item : edges) {
            uf.Union(item[0], item[1]);
        }
        return uf.Count();
    }
};
```



## è¢«å›´ç»•çš„åŒºåŸŸ

1.DFSï¼šä»æœ€å¤–é¢ä¸€åœˆçš„é¡¶ç‚¹å¼€å§‹è¿›è¡Œéå†  ç›¸å½“äºæœ‰å¤šå¼ å›¾

```c++
    void dfs (vector<vector<char>> &board, int x, int y) {
        if(x < 0 || x >= board.size() || y < 0 || y >= board[x].size() || board[x][y] != 'O') return;
 
        board[x][y] = '#'; //è¡¨ç¤ºä¸è¾¹ç•Œçš„Oè¿é€šçš„O
        
        //é¡¶ç‚¹çš„å››ä¸ªæ–¹æ³•
        dfs(board, x-1, y);
        dfs(board, x+1, y);
        dfs(board, x, y-1);
        dfs(board, x, y+1);
    }

    void solve(vector<vector<char>>& board) {
        int n = board.size();
        int m = board[0].size();

        //ä»æœ€å¤–é¢çš„ä¸€åœˆä½œä¸ºDFSçš„èµ·å§‹é¡¶ç‚¹è¿›è¡Œéå†
        for(int i = 0; i < n; ++i) {
            dfs(board, i, 0);
            dfs(board, i, m-1);
        }
        for(int i = 1; i < m-1; ++i) {
            dfs(board, 0, i);
            dfs(board, n-1, i);
        }

        //ç„¶åå°†æ ‡è®°ä¸º#æ”¹ä¸ºO å‰©ä¸‹çš„Oæ”¹ä¸ºX
        for(int i = 0; i < n; ++i) {
            for(int j = 0; j < m; ++j) {
                if(board[i][j] == '#') board[i][j] = 'O';
                else if(board[i][j] == 'O') board[i][j] = 'X';
            }
        }
    }
```

2.å¹¶æŸ¥é›† ==> è¿™é“é¢˜ä½¿ç”¨å¹¶æŸ¥é›†ä¸»è¦é”»ç‚¼ä¸€ä¸‹å°†äºŒç»´çŸ©é˜µçš„ç´¢å¼•è½¬æ¢åˆ°ä¸€ç»´ä¸­

```c++
    void solve(vector<vector<char>>& board) {
        int n = board.size();
        int m = board[0].size();

        UnionFind uf((m * n) + 1);  //é¢„ç•™ä¸€ä¸ªdummyè™šæ‹Ÿçˆ¶èŠ‚ç‚¹ ä¸ºäº†åŒºåˆ«è¾¹ç•ŒOä¸è¢«åŒ…å›´çš„O
        int dummy = m * n;
        //è®©è¾¹ç•Œçš„oéƒ½æŒ‡å‘dummy
        //éå†é¦–è¡Œå’Œæœ«è¡Œ
        for(int i = 0; i < m; ++i) {
            if(board[0][i] == 'O') uf.unio(i, dummy);
            if(board[n-1][i] == 'O') uf.unio((n-1) * m + i, dummy);
        }
        //éå†é¦–åˆ—å’Œæœ«åˆ—
        for(int i = 1; i < n-1; ++i) {
            if(board[i][0] == 'O') uf.unio(i * m + 1, dummy);
            if(board[i][m-1] == 'O') uf.unio((i+1) * m - 1, dummy);
        }

        vector<vector<int>> d = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        //i è¡¨ç¤ºè¡Œ j è¡¨ç¤ºåˆ—
        for(int i = 1; i < n-1; ++i) {
            for(int j = 1; j < m-1; ++j) {
                if(board[i][j] == 'O') {
                    for(int k = 0; k < 4; ++k){
                        //xè¡¨ç¤ºè¡Œå·  yè¡¨ç¤ºåˆ—å·
                        int x = d[k][0] + i;
                        int y = d[k][1] + j;
                        if(board[x][y] == 'O') uf.unio(i * m + j, x * m + y);
                    }
                }
            }
        }

        for(int i = 1; i < n-1; ++i) {
            for(int j = 1; j < m-1; ++j) {
                if(board[i][j] == 'O' && uf.connected(dummy, i * m + j) == false) board[i][j] = 'X';
            }
        }
    }
```



## ç­‰å¼æ–¹ç¨‹å¯æ»¡è¶³æ€§

```c++
    bool equationsPossible(vector<string>& equations) {
        //å› ä¸ºä¸èƒ½æå‰çŸ¥é“ä¸€å…±æœ‰å¤šå°‘ä¸ªå­—æ¯ æ‰€ä»¥å°±å¼€ä¸€ä¸ªåŒ…å«æ‰€æœ‰å°å†™å­—æ¯çš„å¹¶æŸ¥é›†
        UnionFind uf(26);  

        //å…ˆå°†æ‰€æœ‰ç›¸ç­‰çš„è¿›è¡Œåˆå¹¶ ç„¶åå¤„ç†ä¸ç›¸ç­‰çš„
        for(auto &item : equations) {
            if(item[1] == '=') {
                //å‡a æ˜¯é€šè¿‡ASCIIç å°†å°å†™å­—æ¯æ˜ å°„åˆ°0~26ä¹‹é—´ å¹¶ä¸”è½¬åŒ–ä¸ºint
                uf.Union(item[0] - 'a', item[3] - 'a');
            }   
        }

        for(auto &item : equations) {
            if(item[1] == '!') {
                if(uf.Connects(item[0] - 'a', item[3] - 'a')) return false;
            }
        }
        return true;
    }
```



## åˆ¤æ–­å›¾æ˜¯å¦æ˜¯æ ‘

1.å¯ä»¥ä½¿ç”¨DFS æˆ–è€…BFS åˆ¤æ–­æ˜¯å¦æœ‰ç¯å³å¯     ä½†æ˜¯è¿˜è¦å¦å¤–åˆ¤æ–­è¯¥å›¾æ˜¯å¦æ˜¯ä¸€é¢—æ ‘(é¡¶ç‚¹å¿…é¡»å…¨éƒ¨ç›¸è¿)



2.ä½¿ç”¨å¹¶æŸ¥é›† 

```c++
    bool validTree(int n, vector<vector<int>>& edges) {
        UnionFind uf(n);
        for(auto &item : edges) {
            int v1 = item[0], v2 = item[1];
            if(uf.find(v1) == uf.find(v2)) return false;

            uf.Union(v1, v2);
        }

        return uf.count == 1; //æœ€åå¿…é¡»è¦åªæœ‰ä¸€æ£µæ ‘
    }
```

