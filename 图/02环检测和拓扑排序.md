

| ç‰›å®¢ |                           LeetCode                           |                             åŠ›æ‰£                             | éš¾åº¦ |
| :--: | :----------------------------------------------------------: | :----------------------------------------------------------: | :--: |
|  -   | [207. Course Schedule](https://leetcode.com/problems/course-schedule/) | [207. è¯¾ç¨‹è¡¨](https://leetcode.cn/problems/course-schedule/) |  ğŸŸ    |
|  -   | [210. Course Schedule II](https://leetcode.com/problems/course-schedule-ii/) | [210. è¯¾ç¨‹è¡¨ II](https://leetcode.cn/problems/course-schedule-ii/) |  ğŸŸ    |



## DFSç¯æ£€æµ‹

```c++
    bool hasCycle = false;
    vector<bool> visited; 

    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        //éœ€è¦æ„å»ºæœ‰å‘å›¾
        vector<vector<int>> graph(numCourses);
        for(auto &edge : prerequisites) {
            int from = edge[1], to = edge[0];
            graph[from].emplace_back(to);
        }

        vector<bool> path(numCourses, false);
        visited.resize(numCourses, false); 

        //æ¥ä¸‹æ¥éœ€è¦éå†æ•´ä¸ªå›¾ ç„¶ååˆ¤æ–­æœ‰æ— ç¯
        //æ‰€ä»¥éœ€è¦å°è¯•è®©æ¯ä¸€ä¸ªé¡¶ç‚¹éƒ½ä½œä¸ºå¤´é¡¶ç‚¹å¼€å§‹éå†
        for(int i = 0; i < numCourses; ++i) {
            //è¿›è¡Œå‰ªæ å¦‚æœå·²ç»éå†è¿‡å°±ä¸éœ€è¦ä½œä¸ºå¤´é¡¶ç‚¹å†éå†äº†
            //å¦‚æœæ‰€æœ‰é¡¶ç‚¹éƒ½æ˜¯è¿é€šçš„ é‚£ä¹ˆè¿™ä¸ªforå¾ªç¯é‡Œé¢çš„ä»£ç åªä¼šæ‰§è¡Œä¸€æ¬¡
            //åªæœ‰ä¸è¿é€šæ‰ä¼šæ‰§è¡Œå¤šæ¬¡
            if(!visited[i]) {
                dfs(graph, path, i);
            }
        }

        return !hasCycle;
    }

    void dfs (vector<vector<int>> &graph, vector<bool> &path, int s) {
        //åˆ¤æ–­æ˜¯å¦æœ‰ç¯
        if(path[s] == true) hasCycle = true;

        //åªè¦äº§ç”Ÿäº†ç¯å°±ä¸éœ€è¦å†éå†äº† 
        //å¦‚æœséå†è¿‡äº† é‚£ä¹ˆä¹Ÿå¯ä»¥ç›´æ¥é€€å‡º è¿™æ˜¯å‰ªææ“ä½œ
        //å› ä¸ºåªè¦séå†è¿‡äº† è¯´æ˜å®ƒåé¢çš„æ‰€æœ‰é¡¶ç‚¹å·²ç»éå†è¿‡äº† ä¸ä¼šäº§ç”Ÿç¯
        if(hasCycle || visited[s]) return;

        //å› ä¸ºæ˜¯ä»é¡¶ç‚¹çš„è§’åº¦è¿›è¡Œé€’å½’ æ‰€ä»¥åœ¨forå¾ªç¯ä¹‹å‰è¿›è¡Œé¡¶ç‚¹çš„è®°å½•
        visited[s] = true;
        path[s] = true;
        
        for(int &item : graph[s]) dfs(graph, path, item);

        //åœ¨ç¦»å¼€é¡¶ç‚¹æ—¶æ’¤é”€é€‰æ‹©
        path[s] = false;
    }
```

**é—®é¢˜ï¼šä¸Šè¿°ä¸ºä»€ä¹ˆvisited[s] ä¸ºtrueå°±ä¸éœ€è¦éå†è¯¥èŠ‚ç‚¹ï¼Ÿ**

â€‹	**--å› ä¸ºå¦‚æœéå†åˆ°ä¹‹å‰å·²ç»éå†è¿‡çš„èŠ‚ç‚¹  é‚£ä¹ˆå°±è¯´æ˜ä»¥è¯¥èŠ‚ç‚¹ä¸ºèµ·ç‚¹çš„é‚£éƒ¨åˆ†å›¾å·²ç»éå†è¿‡äº†  å°±ä¸ç”¨é‡æ–°éå†äº† ==>  å¤§å¤§å‡å°‘äº†è®¡ç®—é‡**



**visited å’Œ path ä¸¤ä¸ªæ•°ç»„ä»£è¡¨çš„å«ä¹‰ï¼š**

â€‹	**visited æ•°ç»„ç›¸å¯¹äºæ•´ä¸ªå›¾è€Œè¨€   åªè¦ç»è¿‡çš„ç»“ç‚¹éƒ½ä¼šè¢«æ ‡è®°**

â€‹	**path  æ•°ç»„ä»…ä»…ç›¸å¯¹äºæ­£åœ¨éå†çš„è¯¥æ¡è·¯å¾„è€Œè¨€   æ‰€ä»¥åˆ¤æ–­ç¯æ˜¯ä½¿ç”¨pathæ¥æ£€æµ‹**



å¯ä»¥ä½¿ç”¨æŸ“è‰²æ³•ï¼Œå°†visitedæ•°ç»„å®šä¹‰ä¸ºintå‹ï¼Œvisited[s] == 0 è¡¨ç¤ºæœªéå†ï¼Œvisited[s] == 1 è¡¨ç¤ºéå†æ ˆä¸­ï¼Œvisited[s] == 2 è¡¨ç¤ºå·²éå†å®Œæˆï¼Œè¿™æ ·å°±èƒ½ä¸¢å¼ƒonPathæ•°ç»„

```c++
    void DFS (int s, vector<vector<int>> &graph) {
        //0è¡¨ç¤ºè¿˜æœªéå†åˆ° 1è¡¨ç¤ºæ­£åœ¨éå†çš„è·¯å¾„  2è¡¨ç¤ºå·²ç»éå†è¿‡
        if(visited[s] == 1) hasCycle = true;

        if(visited[s] == 2 || hasCycle) return;

        visited[s] = 1;
        for(auto &item : graph[s]) DFS(item, graph);

        visited[s] = 2;
    }   
```



## DFSæ‹“æ‰‘æ’åº

```c++
    vector<int> res;
    vector<bool> path;
    vector<bool> visited;
    bool hasCycle = false;

    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        vector<vector<int>> graph(numCourses);
        for(auto &item : prerequisites) {
            int from = item[1], to = item[0];
            graph[from].emplace_back(to);
        }

        path.resize(numCourses); visited.resize(numCourses);
        for(int i = 0; i < graph.size(); ++i) DFS(graph, i);
		
        //å¦‚æœæœ‰ç¯ å°±æ— æ³•è¿›è¡Œæ‹“æ‰‘æ’åº æ‰€ä»¥è¿”å›ç©ºåˆ—è¡¨
        if(hasCycle) return {};
		
        //å› ä¸ºåœ¨åˆ›å»ºå›¾çš„æ—¶å€™ æˆ‘ä»¬è·¯å¾„èµ·ç‚¹ä½œä¸ºä¾èµ–æº è€Œéè·¯å¾„ç»ˆç‚¹  æ‰€ä»¥åœ¨è¾“å‡ºçš„æ—¶å€™è¦é€†åºè¾“å‡º
        return {res.rbegin(), res.rend()};
    }

    void DFS (vector<vector<int>> &graph, int s) {
        if(path[s]) hasCycle = true;

        if(visited[s] || hasCycle) return;

        visited[s] = true;
        path[s] = true;

        for(auto &item : graph[s]) DFS(graph, item);
		
        //ååºéå†çš„æ¡†æ¶
        res.emplace_back(s);
        path[s] = false;
    }
```





## BFSç¯æ£€æµ‹

```c++
    //ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆæ£€æµ‹ç¯
    //å› ä¸ºå¹¿åº¦ä¼˜å…ˆä¸å¯èƒ½ä¼šéå†åˆ°åŸæ¥çš„é¡¶ç‚¹ æ‰€ä»¥ä¸éœ€è¦visitedæ•°ç»„
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {

        vector<int> indegree(numCourses);
        vector<vector<int>> graph(numCourses);
        for(auto &item : prerequisites) {
            int from = item[1], to = item[0];
            graph[from].emplace_back(to);
            ++indegree[to];
        }

        //å…ˆéå†æ‰¾åˆ°å…¥åº¦æ•°ä¸º0çš„é¡¶ç‚¹ å¹¶å°†å®ƒåŠ å…¥åˆ°é˜Ÿåˆ—ä¸­
        queue<int> q;
        for(int i = 0; i < numCourses; ++i) {
            if(indegree[i] == 0) q.emplace(i);
        }   

        int count = 0; //è®°å½•éå†çš„é¡¶ç‚¹æ•° å¦‚æœä¸è¯¾ç¨‹æ•°ç›®ç›¸åŒåˆ™ä¸å­˜åœ¨ç¯
        while(q.empty() == false) {
            int n = q.size();
            for(int i = 0; i < n; ++i) {
                int cur = q.front(); q.pop();
                ++count;
                //è®©è¯¥é¡¶ç‚¹ç›¸é‚»çš„æ‰€æœ‰é¡¶ç‚¹çš„å…¥åº¦æ•°éƒ½å‡1  ç„¶åå‡ºç°å…¥åº¦ä¸º0å°±åŠ å…¥é˜Ÿåˆ—
                for(int &item : graph[cur]) {
                    --indegree[item];
                    if(indegree[item] == 0) q.emplace(item);
                }
            }
        }

        return count == numCourses;
    }
```



## BFSæ‹“æ‰‘æ’åº

è·Ÿæ£€æµ‹ç¯ç±»ä¼¼  åªæ˜¯å°†++count æ”¹ä¸ºäº† å‘æ•°ç»„ä¸­æ·»åŠ å…ƒç´ 

