

## èƒŒåŒ…é—®é¢˜æ¦‚å¿µï¼š

æœ‰æ€»å®¹é‡é™åˆ¶çš„èƒŒåŒ…  æ¯ä¸ªç‰©å“æœ‰é‡é‡æœ‰ä»·å€¼    æ±‚å¾—èƒ½å¤Ÿè£…ç‰©å“çš„æœ€å¤§ä»·å€¼ ==> è¿™ä¸€ç±»ç›¸å…³çš„é—®é¢˜éƒ½èƒ½å¤Ÿä½¿ç”¨èƒŒåŒ…é—®é¢˜çš„æ€æƒ³æ¥è§£å†³

1. åŠ¨æ€è§„åˆ’é¦–å…ˆå°±æ˜¯è¦æ˜ç¡®æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„çŠ¶æ€ ï¼šå‰©ä½™çš„èƒŒåŒ…å®¹é‡å’Œèƒ½å¤Ÿé€‰æ‹©çš„ç‰©å“
2. èƒ½å¤Ÿé€‰æ‹©çš„è·¯å¾„ï¼šæ—¢ç„¶æŠŠç‰©å“åˆ’åˆ†ä¸ºäº†çŠ¶æ€  é‚£ä¹ˆçŠ¶æ€è½¬ç§»å°±æ˜¯é€‰æ‹©è¯¥ç‰©å“æˆ–è€…ä¸é€‰



## 416åˆ†å‰²ç­‰å’Œå­é›†

æ¯æ¬¡éå†åˆ°ä¸€ä¸ªç‰©å“æ—¶ï¼šå¯ä»¥é€‰æˆ–ä¸é€‰  

1. è®°å¿†åŒ–æœç´¢ï¼šæ‰¾åˆ°æ•°ç»„ä¸­æ˜¯å¦æœ‰å­åºåˆ—çš„å’Œä¸ºtarget (å¯ä»¥åˆ†è§£target  å¹¶ä¸”ä¸èƒ½é‡å¤é€‰æ‹©å…ƒç´ )

```c++
    vector<int> dp; 

    bool canPartition(vector<int>& nums) {
        int sum = accumulate(nums.begin(), nums.end(), 0);
        if(sum & 1) return false;

        int maxNum = *max_element(nums.begin(), nums.end());
        int target = sum / 2;
        if(target < maxNum) return false;

        dp.resize(target+1);  //dp:0è¡¨ç¤ºæœªéå†åˆ° 1è¡¨ç¤ºæœ‰è¯¥targetç»„åˆ -1è¡¨ç¤ºæ— è¯¥targetç»„åˆ
        return backTrack(nums, 0, target);
    }

    //è¿”å›æ˜¯å¦æœ‰å’Œä¸ºtargetçš„å­åºåˆ—
    bool backTrack (vector<int> &nums, int idx, int target) {
        if(target < 0) return false;

        if(dp[target] != 0) return dp[target] == 1 ? true : false;

        if(target == 0) return true;
        
        bool hasFind = false;
        for(int i = idx; i < nums.size(); ++i) {
            hasFind |= backTrack(nums, i+1, target - nums[i]);
            if(hasFind) break;
        }

        dp[target] = hasFind ? 1 : -1; //æœ‰å’Œä¸ºtargetçš„å­åºåˆ—åˆ™ä¸º1 æ— å°±ä¸º-1
        return hasFind;
    }
```



2. åŠ¨æ€è§„åˆ’(äºŒç»´æ•°ç»„)

```c++
    bool canPartition(vector<int>& nums) {
        int sum = accumulate(nums.begin(), nums.end(), 0);
        if(sum & 1) return false;

        int target = sum / 2;
        int maxNum = *max_element(nums.begin(), nums.end());
        if(maxNum > target) return false;

        int n = nums.size();
        //dp[i][j]ï¼šå‰iä¸ªæ•°æ˜¯å¦æœ‰å­åºåˆ—å’Œä¸ºj ==> dp[n-1][target]:æ•´ä¸ªæ•°ç»„ä¸­æ˜¯å¦æœ‰å­åºåˆ—å’Œä¸ºtarget
        vector<vector<bool>> dp(n, vector<bool>(target+1));
        for(int i = 0; i < n; ++i) dp[i][0] = 1;
        dp[0][nums[0]] = 1;

        for(int i = 1; i < n; ++i) {
            int num = nums[i];
            for(int j = 1; j <= target; ++j) {
                if(j < num) dp[i][j] = dp[i-1][j];
                else dp[i][j] = dp[i-1][j] || dp[i-1][j-num];
            }
        }

        return dp[n-1][target];
    }
```



ç”±äºçŠ¶æ€è½¬ç§»éƒ½æ˜¯ä»å‰é¢ä¸€è¡Œè½¬ç§»è¿‡æ¥çš„  å› æ­¤å¯ä»¥å°†äºŒç»´dpå‹ç¼©æˆä¸€ç»´

```c++
    bool canPartition(vector<int>& nums) {
        int sum = accumulate(nums.begin(), nums.end(), 0);
        if(sum & 1) return false;

        int target = sum / 2;
        int maxNum = *max_element(nums.begin(), nums.end());
        if(maxNum > target) return false;

        int n = nums.size();
        vector<bool> dp(target+1);
        dp[0] = 1;

        for(int i = 0; i < n; ++i) {
            int num = nums[i];
            //éœ€è¦æ³¨æ„æ˜¯ä»åé¢å¾€å‰éå†
            for(int j = target; j >= 0; --j) {
                if(j >= num) {
                    dp[j] = dp[j] || dp[j-num];
                }
            }
        }

        return dp[target];
    }
```



## é—®é¢˜ï¼šä¸ºä»€ä¹ˆé›¶é’±å…‘æ¢æ˜¯å…ˆéå†amountå†éå†æ•°ç»„   è€Œåˆ†å‰²å­é›†æ˜¯å…ˆéå†æ•°ç»„å†éå†target

å¯ä»¥ç±»æ¯”é›¶é’±å…‘æ¢ å’Œ åˆ†å‰²å­é›† çš„è®°å¿†åŒ–æœç´¢  ==>  é›¶é’±å…‘æ¢å®ƒçš„æ·±åº¦(çŠ¶æ€æ€»æ•°)å–å†³äºamount  

â€‹																			ğŸ‘† å®ƒçš„å…ƒç´ ä¸ªæ•°æ— é™  åªè¦å¢åŠ amountå°±éœ€è¦æ£€æŸ¥æ˜¯å¦æœ‰å…ƒç´ èƒ½å¤Ÿç»„æˆè¯¥amount 

  è€Œåˆ†å‰²å­é›†çš„é€’å½’æ·±åº¦(çŠ¶æ€æ¨å¯¼)å–å†³äºå…ƒç´ çš„ä¸ªæ•°

ğŸ‘† å®ƒçš„å…ƒç´ ä¸ªæ•°æœ‰é™  åªè¦å¢åŠ ä¸€ä¸ªå…ƒç´  å°±è¦æ£€æŸ¥æ˜¯å¦èƒ½å¤Ÿé€šè¿‡è¯¥å…ƒç´ æ„æˆæ›´å¤§çš„amount(ç›´åˆ°target)

